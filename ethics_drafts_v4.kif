;; I'll start with the latest version of Deciding

;; It seems helpful to have a wrapper for classes that allows them to be treated as instances.
;; Sort of an inverse of the KappaFn?  -- I think for the reverse direction, KappaFn should be used.
;; I would wish to define a subclass of Set for Sets of Instances to make the type checking easier.
(documentation ClassToSetFn EnglishLanguage "A UnaryFunction that maps a Class into the set of instances of the Class.")
(domainSubclass ClassToSetFn 1 Class)
(instance ClassToSetFn TotalValuedRelation)
(instance ClassToSetFn UnaryFunction)
(range ClassToSetFn Set)

(<=>
  (element ?INSTANCE (ClassToSetFn ?CLASS))
  (instance ?INSTANCE ?CLASS))
        
;; All patients of deciding are sets corresponding to classes of intentional processes.
(=>
  (and
    (instance ?DECIDE Deciding)
    (patient ?DECIDE ?OPTIONSET))
  (exists (?CLASS)
    (and
      (equal (ClassToSetFn ?CLASS) ?OPTIONSET)
      (subclass ?CLASS IntentionalProcess))))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (patient ?DECIDE (ClassToSetFn ?OPTION)))
  (believes ?AGENT
    (capability ?OPTION agent ?AGENT)))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (result ?DECIDE (ClassToSetFn ?DECISION)))
  (believes ?AGENT
    (holdsDuring
      (FutureFn
        (WhenFn ?DECIDE))
      (exists (?P)
        (and
          (instance ?P ?DECISION)
          (agent ?P ?AGENT)
          (earlier
            (WhenFn ?DECIDE)
            (WhenFn ?P)))))))


;; And the 'alternative' set of classes approach to make it easier to find and reference.
;; Suppose we go with the idea to represent the set of options in a decision in terms of a set.
;; Then we want to say that all the elements thereof are intentional processes.                                      
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;   (subclass ?O IntentionalProcess))

;; For every instance of deciding, there is a non-empty set over which one is deciding.
; (=>
;   (instance ?DECIDE Deciding)
;   (exists (?S)
;     (and
;       (instance ?S NonNullSet)
;       (patient ?DECIDE ?S))))

;; For every option in a decision set for an agent,
;; the agent believes itself capable of performing this option.   
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;     (believes ?AGENT 
;       (capability ?O agent ?AGENT)))

;;  For every resulting decision set element, the agent believes it will enact that behavior in the future.  
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set)
;     (element ?O ?S))
;   (believes ?AGENT
;     (holdsDuring 
;       (FutureFn
;         (WhenFn ?DECIDE))
;       (exists (?P)
;         (and
;           (instance ?P ?O)
;           (agent ?P ?AGENT))))))

;; The resulting decision-set is a subset of some decision set being decided over.       
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set))
;   (exists (?S)
;     (and
;       (patient ?DECISION ?S)
;       (subset ?DECISION ?S))))

;; This should ontologically work for the Virtue ethics case without providing a specific measure.
(documentation similar EnglishLanguage "The predicate similar attempts to capture the ontologic notion of similarity 
from a subjective point of view. (similar ?A ?E1 ?E2) means that ?E1 and ?E2 are similar to cognitive agent ?A.")
(instance similar TernaryPredicate)  
(domain similar 1 CognitiveAgent)
(domain similar 2 Entity)
(domain similar 3 Entity)

(=>
  (similar ?A ?E1 ?E2)
  (forall (?J1 ?J2 ?O1 ?O2)
    (=>
      (and
        (instance ?J1 Judging)
        (instance ?O1 Formula)
        (agent ?J1 ?A)
        (patient ?J1 ?E1)
        (result ?J1 ?O1)
        (instance ?J2 Judging)
        (instance ?O2 Formula)
        (agent ?J2 ?A)
        (patient ?J2 ?E2)
        (result ?J2 ?O2))
      (modalAttribute
        (similar ?A ?O1 ?O2) Likely))))

;; This might help.
(=>
  (equal ?E1 ?E2)
  (forall (?A)
    (similar ?A ?E1 ?E2)))

(<=>
  (similar ?A ?E1 ?E2)
  (similar ?A ?E2 ?E1))

(documentation MoralAttribute EnglishLanguage "Moral Attributes are a subcass of Normative Attributes intended to denote whether something is Good, Bad, Right, Wrong, Virtuous, Viceful, or other moral attributes.")
(subclass MoralAttribute NormativeAttribute)

(instance MorallyGood MoralAttribute)
(instance MorallyBad MoralAttribute)
(instance MorallyNeutral MoralAttribute)

(subclass VirtueAttribute MoralAttribute)
(subclass ViceAttribute MoralAttribute)

(subclass VirtueAttribute PsychologicalAttribute)
(subclass ViceAttribute PsychologicalAttribute)

;; Do we want a moral attribute for utilitarianism?

;; Generally speaking, yes.  Might some paraconsistency reign?  :- p
(contraryAttribute MorallyGood MorallyBad)
(contraryAttribute MorallyGood MorallyNeutral)
(contraryAttribute MorallyBad MorallyNeutral)
(contraryAttribute VirtueAttribute ViceAtribute)

;; Why not say it explicitly, too.  
(=>
  (modalAttribute ?F MorallyGood)
  (not (modalAttribute ?F MorallyBad)))
  
(=>
  (modalAttribute ?F MorallyGood)
  (not (modalAttribute ?F MorallyNeutral)))
  
(=>
  (modalAttribute ?F MorallyBad)
  (not (modalAttribute ?F MorallyGood)))
  
(=>
  (modalAttribute ?F MorallyBad)
  (not (modalAttribute ?F MorallyNeutral)))
  
(=>
  (modalAttribute ?F MorallyNeutral)
  (not (modalAttribute ?F MorallyGood)))
  
(=>
  (modalAttribute ?F MorallyNeutral)
  (not (modalAttribute ?F MorallyBad)))

(documentation VirtuousAgent EnglishLanguage "'A virtuous agent is one who has, and exercises, certain character traits, namely, the virtues.' (On Virtue Ethics)")
(subclass VirtuousAgent AutonomousAgent)

;; Draft 3: Note that it is quantifying over all virtues!  
;; A very strong requirement for a virtuous agent, lol.
(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VIRTUE VirtueAttribute)
    (attribute ?AGENT ?VIRTUE))
  (instance ?AGENT VirtuousAgent))

;; Draft 4: This version seems better: an agent posessing a virtue increases the likelihood that the agent is virtuous ;- ).
(increasesLikelihood
  (exists (?VIRTUE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VIRTUE VirtueAttribute)
      (attribute ?AGENT ?VIRTUE)))
  (instance ?AGENT VirtuousAgent))
  
(=>
  (instance ?AGENT VirtuousAgent)
  (exists (?VIRTUE)
    (attribute ?AGENT ?VIRTUE)))
  
(documentation ViciousAgent EnglishLanguage "A vicious agent is one who has, and exercises, certain character traits, namely, the vices.  The antonym of VirtuousAgent.")
(subclass ViciousAgent AutonomousAgent)

(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VICE ViceAttribute)
    (attribute ?AGENT ?VICE))
  (instance ?AGENT ViciousAgent))
  
(increasesLikelihood
  (exists (?VICE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VICE ViceAttribute)
      (attribute ?AGENT ?VICE)))
  (instance ?AGENT ViciousAgent))
  
(=>
  (instance ?AGENT ViciousAgent)
  (exists (?VICE)
    (attribute ?AGENT ?VICE)))

;; Encapsulate the Autonomous Agent aspect of "behavior"-type processes.
(documentation AutonomousAgentProcess EnglishLanguage "AgentProcess is the Class of all Processes in which there is an autonomous agent.")
(subclass AutonomousAgentProcess Process)
(subclass BodyMotion AutonomousAgentProcess)
(subclass Vocalizing AutonomousAgentProcess)

(=>
  (instance ?PROC AutonomousAgentProcess)
  (exists (?AGENT)
    (and
      (agent ?PROC ?AGENT)
      (instance ?AGENT AutonomousAgent))))

;; A theory is a set of sentences (in a formal language).
(documentation Theory EnglishLanguage "A set of sentences.")
(subclass Theory Set)

(<=>
  (instance ?T Theory)
  (forall (?S)
    (=>
      (element ?S ?T)
      (instance ?S Sentence))))

(documentation MoralTheory EnglishLanguage "A set of sentences in a moral theory")
(subclass MoralTheory Theory)

;; Insert rules
;; I'm tempted to partition it but that's crude as there is at least one paradigm I haven't covered (morally nihilistic theories).

;; Maybe I should have a "theory of type X" predicate instead but this seems cleaner.
(documentation MoralSentence EnglishLanguage "A sentence of a moral theory")
(subclass MoralSentence Sentence)

(<=>
  (instance ?SENTENCE MoralSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY MoralTheory)
      (element ?SENTENCE ?THEORY))))

(documentation DeontologicalTheory EnglishLanguage "A set of sentences assigning moral attributes.")
(subclass DeontologicalTheory MoralTheory)

(documentation DeontologicalSentence EnglishLanguage "A sentence of a deontological language/theory.")      
(subclass DeontologicalSentence MoralSentence)

(<=>
  (instance ?SENTENCE MoralSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY DeontologicalTheory)
      (element ?SENTENCE ?THEORY))))

(documentation SimpleValueJudgmentSentence EnglishLanguage "A sentence that describes the attribution of a moral value judgment.")      
(subclass SimpleValueJudgmentSentence DeontologicalSentence)

(<=>
  (instance ?SENTENCE SimpleValueJudgmentSentence)
  (exists (?F ?MORALATTRIBUTE)
    (and
      (equal (modalAttribute ?F ?MORALATTRIBUTE) ?SENTENCE)
      (instance ?F Formula)
      (or
        (equal ?MORALATTRIBUTE MorallyGood)
        (equal ?MORALATTRIBUTE MorallyBad)
        (equal ?MORALATTRIBUTE MorallyNeutral)))))

(documentation ValueJudgmentSentence EnglishLanguage "A sentence that describes the attribution of a moral value judgment.")      
(subclass ValueJudgmentSentence DeontologicalSentence)

(<=>
  (instance ?SENTENCE ValueJudgmentSentence)
  (exists (?VJS)
    (and
      (instance ?VJS SimpleValueJudgmentSentence)
      (part ?VJS ?SENTENCE))))

(documentation SimpleImperativeSentence EnglishLanguage "A sentence that describes an imperative deontic operator.")      
(subclass SimpleImperativeSentence DeontologicalSentence)

(<=>
  (instance ?SENTENCE SimpleImperativeSentence)
  (exists (?F ?DEONTICATTRIBUTE)
        (and
          (equal (modalAttribute ?F ?DEONTICATTRIBUTE) ?SENTENCE)
          (instance ?F Formula)
          (instance ?DEONTICATTRIBUTE DeonticAttribute))))

(documentation ImperativeSentence EnglishLanguage "A sentence that describes an imperative deontic operator.")      
(subclass ImperativeSentence DeontologicalSentence)    

(<=>
  (instance ?SENTENCE ImperativeSentence)
  (exists (?IT)
    (and
      (instance ?IT SimpleImperativeSentence)
      (part ?IT ?SENTENCE))))

(documentation DeontologicalValueJudgmentTheory EnglishLanguage "A set of sentences assigning moral attributes.")
(subclass DeontologicalValueJudgmentTheory DeontologicalTheory)

;; A deontological theory is one where for every sentence, there exists a formula and moral attribute 
;; such that the sentence assigns this  moral attribute to the formula.
;;  I think the inverse direction works for the Virtue and Utilitarian approaches as we're not quantifying over general formulas.
;; Yet I am not fully sure how I wish to constrain formulas.
;; Existential formulas over processes or physical entities or... what?
(=>
  (instance ?D DeontologicalValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (exists (?F ?MORALATTRIBUTE)
        (and
          (equal ?S
            (modalAttribute ?F ?MORALATTRIBUTE))
          (instance ?F Formula)
          (or
            (equal ?MORALATTRIBUTE MorallyGood)
            (equal ?MORALATTRIBUTE MorallyBad)))))))

;; The above is too strong.  The sentence may describe the context in which the moral judgment is being dished out.
(=>
  (instance ?D DeontologicalValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (exists (?F ?MORALATTRIBUTE)
        (and
          (part (modalAttribute ?F ?MORALATTRIBUTE) ?S)
          (instance ?F Formula)
          (or
            (equal ?MORALATTRIBUTE MorallyGood)
            (equal ?MORALATTRIBUTE MorallyBad)
            (equal ?MORALATTRIBUTE MorallyNeutral)))))))

;; Now I can simplify things and say that a Deontological Value Judgment Theory is one in which all sentences contain a value judgment sentence as a part!
(=>
  (instance ?D DeontologicalValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (instance ?S ValueJudgmentSentence))))
            
(documentation DeontologicalImperativeTheory EnglishLanguage "A set of sentences containing moral imperatives.")
(subclass DeontologicalImperativeTheory DeontologicalTheory)

(=> 
  (instance ?MT DeontologicalImperativeTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (instance ?S ImperativeSentence))))
          
(documentation VirtueEthicsTheory EnglishLanguage "A set of sentences assigning virtue or vice attributes.")
(subclass VirtueEthicsTheory MoralTheory)
                    
(<=>
  (instance ?V VirtueEthicsTheory)
  (forall (?S)
    (=>
      (element ?S ?V)
      (exists (?AGENT ?VIRTUE)
        (and
          (equal ?S
            (attribute ?AGENT ?VIRTUE))
          (instance ?AGENT AutonomousAgent)
          (or
            (instance ?VIRTUE VirtueAttribute)
            (instance ?VIRTUE ViceAttribute)))))))
            
(documentation UtilitarianTheory EnglishLanguage "A set of sentences dealing with the utility of behaviors.")
(subclass UtilitarianTheory MoralTheory)

(<=>
  (instance ?U UtilitarianTheory)
  (forall (?S)
    (=>
      (element ?S ?U)
      (exists (?CBEHAVE ?CBEHAVE2 ?N ?C)
        (and
          (subclass ?CBEHAVE AutonomousAgentProcess)
          (subclass ?CBEHAVE2 AutonomousAgentProcess)
          (or
            (equal ?S
              (
                (?C
                  (UtilitySubclassFn ?CBEHAVE) ?N)))
            (equal ?S
              (?C
                (UtilitySubclassFn ?CBEHAVE)
                (UtilitySubclassFn ?CBEHAVE2))))
          (instance ?N Number)
          (or
            (equal ?C greaterThan)
            (equal ?C lessThan)
            (equal ?C greaterThanOrEqualTo)
            (equal ?C lessThanOrEqualTo)
            (equal ?C equal)))))))

;; This is actually really clean.  No mucking around in saying that it is judging behavioral (instances or classes), etc.
(documentation MoralJudging EnglishLanguage "A subclass of Judging where the proposition believed is 
a moral sentence from a moral theory (in a given paradigm).")
(subclass MoralJudging Judging)

(=>
  (instance ?JUDGE MoralJudging)
  (exists (?SENTENCE)
    (and
      (instance ?SENTENCE MoralSentence)
      (result ?JUDGE ?SENTENCE))))

(documentation Ethics EnglishLanguage "Ethics is the normative science of the conduct of human beings living in society, 
which judges this conduct to be right or wrong, to be good or bad, or in some similar way. (An Introduction to Ethics (Lillie, 1948))")
(subclass Ethics Philosophy)
(subclass Ethics Science) 

(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging))
;; The reference definition includes judging (and normativity), so referring to the theory w/o judging/interpreting the theory is
;; "Necessary but not sufficient".
(and
  (refers Ethics ?THEORY)
  (instance ?THEORY MoralTheory))
  
;; Ethics refers to the judgment by a group of a member via a moral sentence (that refers to the member).
;; It gets a bit vague abstracting out behavior, lol.  
;; Note that the English says that a subCollection is a "proper part", however there is no rule that implies this.  
(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging)
  (instance ?GROUP Group)
  (agent ?JUDGE ?AGENT)
  (or
    (member ?AGENT ?GROUP)
    (part ?AGENT ?GROUP))
  (member ?MEMB ?GROUP)
  (patient ?JUDGE ?SENTENCE)
  (instance ?SENTENCE MoralSentence)
  (refers ?SENTENCE ?MEMB))

;; Let's get a version that works with moral theories.
;; Ethics refers to a moral theory and a group where each sentence is believed to be true by the group
;; and each sentence refers to a behavior such that it's believed some member of the group is capable of this behavior.
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (and
        (believes ?GROUP ?S)
        (refers ?S (ClassToSetFn ?B))
        (subclass ?B AutonomousAgentProcess)
        (believes ?GROUP
          (exists (?MEMB)
            (and
              (member ?MEMB ?GROUP)
              (capability ?B agent ?MEMB))))))))

;; As this 'belief' is the result of the moral judgment, we can throw moral judgments in.
;; This implies that ?S is believed.
;; However, it also implies that prior to the act of judgment, it was not believed to be so. 
;; Which implies some judgment process by which this moral sentence came to be believed.
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?JUDGE)
        (and
          (instance ?JUDGE MoralJudging)
          (agent ?JUDGE ?GROUP)
          (result ?JUDGE ?S)
          (refers ?S (ClassToSetFn ?B))
          (subclass ?B AutonomousAgentProcess)
          (believes ?GROUP
            (exists (?MEMB)
              (and
                (member ?MEMB ?GROUP)
                (capability ?B agent ?MEMB)))))))))

;; Decided that by their structure, the sentences do not necessarily refer to behavior.
;; The moral judgment process may, however!
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?JUDGE)
        (and
          (instance ?JUDGE MoralJudging)
          (agent ?JUDGE ?GROUP)
          (result ?JUDGE ?S)
          (refers ?JUDGE (ClassToSetFn ?B))
          (subclass ?B AutonomousAgentProcess)
          (believes ?GROUP
            (exists (?MEMB)
              (and
                (member ?MEMB ?GROUP)
                (capability ?B agent ?MEMB)))))))))

(documentation MoralNihilism EnglishLanguage "'Moral Nihilism is the view that nothing is morally wrong' (SEP - Moral Skepticism). 
Moral Nihilism can also be defined as 'the view that there are no moral facts' (Ethics: The Fundamentals).")
(subclass MoralNihilism Ethics)
  
(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?MORALSTATEMENT)
            (and
              (instance ?MORALSTATEMENT MoralSentence)
              (instance ?MORALSTATEMENT Fact))))))))

(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?BEHAVIORCLASS)
            (and
              (subclass ?BEHAVIORCLASS AutonomousAgentProcess)
              (modalAttribute
                (exists (?BEHAVIORINSTANCE)
                  (instance ?BEHAVIORINSTANCE ?BEHAVIORCLASS)) MorallyWrong))))))))
                          
(documentation realizesFormula EnglishLanguage "(conforms ?PROC ?FORMULA) describes how ?PROC follows the ideas outlined by the proposition represented by ?FORMULA.")

(domain realizesFormula 1 Process)
(domain realizesFormula 2 Formula)
(instance realizesFormula BinaryPredicate)
(subrelation realizesFormula represents)

;; A process conforms to a formula if and only if there exists a proposition such that:
;; a) the formula contains the information of the proposition.
;; b) the process is the realization of the proposition.
(<=>
  (realizesFormula ?PROCESS ?FORMULA)
  (exists (?PROP)
    (and
      (containsInformation ?FORMULA ?PROP)
      (realization ?PROCESS ?PROP))))

(documentation realizesFormulaSubclass EnglishLanguage "(conforms ?CPROC ?FORMULA) describes how ?CPROC follows the ideas outlined by the proposition represented by ?FORMULA.")

(domainSubclass realizesFormulaSubclass 1 Process)
(domain realizesFormulaSubclass 2 Formula)
(instance realizesFormulaSubclass BinaryPredicate)
(subrelation realizesFormulaSubclass represents)              
                                            
;; A subclass of Process conforms to a formula if there exists a proposition such that:
;; a) the formula contains the information of the proposition.
;; b) all instances of the subclass are realizations of the proposition.
(<=>
  (realizesFormulaSubclass ?CPROCESS ?FORMULA)
  (exists (?PROP)
    (and
      (containsInformation ?FORMULA ?PROP)
      (forall (?IPROCESS)
        (=>
          (instance ?IPROCESS ?CPROCESS)
          (realization ?IPROCESS ?PROP))))))

(documentation Deontology EnglishLanguage "Deontology is the ethical paradigm that judges the morality of an action 
based on the action adheres to a set of rules and principles.")
(subclass Deontology Ethics)

;; Hmm, how to do this is tricky.  Why say that the process is something YOU do?  It's just good for there to be some process realizing obligations, right?
;; Also, I'm not sure how to mix in the deontological language.
;; The below will be very experimental!
(=>
  (instance ?D Deontology)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (exists (?RULE ?DEONTIC)
          (and
            (instance ?DEONTIC DeonticAttribute)
            (modalAttribute ?RULE ?DEONTIC)
            (=>
              (modalAttribute ?RULE Obligation)
              (modalAttribute
                (exists (?PROCESS)
                  (realizesFormula ?PROCESS ?RULE)) MorallyGood))))))))

;; All instances of deontology have subpropositions that contain moral sentences.
;; These moral sentences are elements of a deontological theory.
;; I think this is good to say.  Clearly I want a "this sentence is a deontological sentence" shorthand".
;;                
(=>
  (instance ?D Deontology)
  (exists (?PROP ?SENT)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?SENT ?PROP)
      (instance ?SENT MoralSentence)
      (exists (?THEORY)
        (and 
          (instance ?THEORY DeontologicalTheory)
          (element ?SENT ?THEORY))))))
          
(=>
  (instance ?MT DeontologicalTheory)
  (exists (?MP)
    (and
      (instance ?MP Deontology)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP))))))))
              
;; What about something whacky like this?
;; There exists a moral theory and a moral philosophy such that
;; every sentence of the moral theory is contained in the moral philosophy
;; and for every sentence, there is a corresponding rule?
(exists (?MT ?MP)
  (and
    (instance ?MP Deontology)
    (instance ?MT DeontologicalValueJudgmentTheory)
    (forall (?S)
      (=>
        (element ?S ?MT)
        (and
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP)))
          (exists (?RULE ?DEONTIC)
            (and
              (instance ?DEONTIC DeonticAttribute)
              (modalAttribute ?RULE ?DEONTIC)
              (=>
                (equal ?DEONTIC Obligation)
                (equal ?S
                  (and
                    (modalAttribute
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE)) MorallyGood)
                    (modalAttribute
                      (not
                        (exists (?PROC)
                          (realizesFormula ?PROC ?RULE))) MorallyBad)))))))))))
            
;; This can be modularly simplified!
(exists (?MT)
  (and
    (instance ?MT DeontologicalValueJudgmentTheory)
    (forall (?S)
      (=>
        (element ?S ?MT)
        (exists (?RULE ?DEONTIC)
          (and
            (instance ?DEONTIC DeonticAttribute)
            (modalAttribute ?RULE ?DEONTIC)
            (=>
              (equal ?DEONTIC Obligation)
              (equal ?S
                (and
                  (modalAttribute
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE)) MorallyGood)
                  (modalAttribute
                    (not
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE))) MorallyBad))))))))))

;; This function basically is what I've been calling "Deontology":
;; A mapping from imperative-type deontological sentences into value judgment-type deontological sentences
;; And then the mapping of Moral Judgments over the sentences as if to say, 
;; Society has considered these moral sentences and concluded them to be 'true' (or whatever else one does with them).
(documentation ImperativeToValueJudgmentSentenceFn EnglishLanguage "A UnaryFunction that maps simple imperative sentences into value judgment sentences.")
(domain ImperativeToValueJudgmentSentenceFn 1 SimpleImperativeSentence)
(range ImperativeToValueJudgmentSentenceFn ValueJudgmentSentence)
(instance ImperativeToValueJudgmentSentenceFn TotalValuedRelation)
(instance ImperativeToValueJudgmentSentenceFn UnaryFunction)

(=> 
  (and 
    (equal (ImperativeToValueJudgmentSentenceFn ?ITS) ?VJS)
    (equal ?ITS (modalAttribute ?RULE ?DEONTIC))
    (instance ?RULE Formula)
    (instance ?DEONTIC DeonticAttribute))
  (and
    (=>
      (equal ?DEONTIC Obligation)
      (equal ?VJS
        (and
          (modalAttribute
            (exists (?PROC)
              (realizesFormula ?PROC ?RULE)) MorallyGood)
          (modalAttribute
            (not
              (exists (?PROC)
                (realizesFormula ?PROC ?RULE))) MorallyBad))))
    (=>
      (equal ?DEONTIC Prohibition)
      (equal ?VJS
        (modalAttribute
          (exists (?PROC)
            (realizesFormula ?PROC ?RULE)) MorallyBad)))
    (=>
      (equal ?DEONTIC Permission)
      (equal ?VJS
        (forall (?CPROC)
          (=>
            (realizesFormulaSubclass ?CPROC ?RULE)
            (modalAttribute
              (exists (?PREN)
                (and
                  (instance ?PREN AutonomousAgentProcess)
                  (prevents ?PREN ?CPROC))) MorallyBad))))))) 
     
;; Let's just say that the standard deontic operators cover all deontolgical theories.
;; Assuming rights-based approaches etc can be translated into this form ;- )
(=>
  (instance ?MT DeontologicalValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?RULE ?DEONTIC)
        (and
          (instance ?DEONTIC DeonticAttribute)
          (modalAttribute ?RULE ?DEONTIC)
          (=>
            (equal ?DEONTIC Obligation)
            (equal ?S
              (and
                (modalAttribute
                  (exists (?PROC)
                    (realizesFormula ?PROC ?RULE)) MorallyGood)
                (modalAttribute
                  (not
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE))) MorallyBad))))
          (=>
            (equal ?DEONTIC Prohibition)
            (equal ?S
              (modalAttribute
                (exists (?PROC)
                  (realizesFormula ?PROC ?RULE)) MorallyBad)))
          (=>
            (equal ?DEONTIC Permission)
            (equal ?S
              (forall (?CPROC)
                (=>
                  (realizesFormulaSubclass ?CPROC ?RULE)
                  (modalAttribute
                    (exists (?PREN)
                      (and
                        (instance ?PREN AutonomousAgentProcess)
                        (prevents ?PREN ?CPROC))) MorallyBad))))))))))

;; Let's see what it looks like if I place everything within the modalAttribute.
(=>
  (instance ?MT DeontologicalValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?RULE ?DEONTIC)
        (and
          (instance ?DEONTIC DeonticAttribute)
          (modalAttribute ?RULE ?DEONTIC)
          (=>
            (equal ?DEONTIC Obligation)
            (exists (?S2 ?G ?B)
              (and
                (element ?S2 ?MT)
                (equal ?G
                  (modalAttribute
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE)) MorallyGood))
                (equal ?B
                  (modalAttribute
                    (not
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE))) MorallyBad))
                (or 
                  (and (equal ?S ?G) (equal ?S2 ?B))
                  (and (equal ?S ?B) (equal ?S2 ?G))))))
          (=>
            (equal ?DEONTIC Prohibition)
            (equal ?S
              (modalAttribute
                (exists (?PROC)
                  (realizesFormula ?PROC ?RULE)) MorallyBad)))
          (=>
            (equal ?DEONTIC Permission)
            (exists (?S2 ?TEMP1 ?TEMP2)
              (and
                (element ?S2 ?MT)
                (equal ?TEMP1
                  (modalAttribute
                    (exists (?CPROC)
                      (realizesFormulaSubclass ?CPROC ?RULE)) MorallyNeutral))
                (equal ?TEMP2
                    (modalAttribute
                        (exists (?CPROC ?PREN)
                          (and
                            (realizesFormulaSubclass ?CPROC ?RULE)
                            (exists (?PREN)
                              (and
                                (instance ?PREN AutonomousAgentProcess)
                                (prevents ?PREN ?CPROC))))) MorallyBad))
                (or 
                  (and (equal ?S ?TEMP1) (equal ?S2 ?TEMP1))
                  (and (equal ?S ?TEMP2) (equal ?S2 ?TEMP2)))))))))))

;; I think to do this I need to define the structure of a SimpleValueJudgmentSentence as well as a ImperativeSentence.
;; Then I can say that for all parts either they are equal or they are an ImperativeSentence which is equivalent to the SimpleValueJudgmentSentence.
;; And I wish to say that the theories are equivalent but... in terms of what?
;; I'll also do the reverse mapping...?  Hmm.
;; Well, this is my OPPA Mapping Style!
;; Oh, I could actually just define the map, lol!
;; (=> 
;;   (instance ?IT DeontologicalImperativeTheory)
;;   (exists (?DT)
;;     (and
;;       (instance ?DT DeontologicalValueJudgmentTheory)
;;       (forall (?S1)
;;         (=> 
;;           (element ?S1 ?IT)
;;           (and
;;             (=> 
;;               (not (instance ?S1 ?SimpleImperativeSentence))))))))

(documentation VirtueEthics EngnlishLanguage "Virtue ethics is the ethical paradigm that judges the morality of an action 
based on the character of the agent performing an action.  A virtuous agent is one who possesses virtues.  
'An action is right if and only if it is what a virtuous agent would characteristically (i.e., acting in caharacter) 
do in the circumstances' (On Virtue Ethics -- Right Action).")
(subclass VirtueEthics Ethics)

;; Linking Virtue Ethics with its Theories.
(=>
  (instance ?D VirtueEthics)
  (exists (?PROP ?SENT)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?SENT ?PROP)
      (instance ?SENT MoralSentence)
      (exists (?THEORY)
        (and
          (instance ?THEORY VirtueEthicsTheory)
          (element ?SENT ?THEORY))))))
          
(=>
  (instance ?MT VirtueEthicsTheory)
  (exists (?MP)
    (and
      (instance ?MP VirtueEthics)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP))))))))

; (=>
;   (instance ?MT VirtueEthicsTheory)
;   (forall (?S)
;     (=>
;       (element ?S ?MT)  )))                              
(and
  (refers VirtueEthics ?STATE)
  (instance ?STATE Statement)
  (equals ?STATE
    (<=>
      (and
        (instance ?JUDGE MoralJudging)
        (agent ?JUDGE ?AGENTJ)
        (patient ?JUDGE
          (modalAttribute
            (hasInstance ?CBEHAVE) MorallyGood)))
      (believes ?AGENTJ
        (=>
          (and
            (instance ?DECIDE DecidingSubclass)
            (result ?DECIDE ?CBEHAVE)
            (subclass ?CBEHAVE AutonomousAgentProcess)
            (agent ?DECIDEV ?AGENTV)
            (instance ?AGENTV VirtuousAgent)
            (instance ?DECIDEV DecidingSubclass)
            (similar ?AGENTJ
              (DecisionSubclassOptionFn ?DECIDE)
              (DecisioSubclassnOptionFn ?DECIDEV)))
          (modalAttribute
            (result ?DECIDEV ?CBEHAVE) Likely))))))


(documentation Utilitarianism EnglishLanguage "Utilitarianism is the ethical paradigm that judges the morality of an action 
based on whether it maximizes the good over the bad, which is typically determined via a utility function.")
(subclass Utilitarianism Ethics)

(documentation HedonisticUtilitarianism EnglishLanguage "Hedonistic Utilitarianism is a form of utilitarianism that focuses on maximizing pleasure and minimizing pain in evaluating the moral value of an action.")
(subclass HedonisticUtilitarianism Utilitarianism)

(documentation Consequentialism EnglishLanguage "Consequentialism is a moral theory that holds that 'whether an act is morally right depends only on consequences (as opposed to the circumstances or the intrinsic nature of the act or anything that happens before the act)' (Stanford Encyclopedia of Philosophy).")
(subclass Consequentialism Utilitarianism)                    