;; I'll start with the latest version of Deciding

(documentation ClassToSetFn EnglishLanguage "A UnaryFunction that maps a Class into the set of instances of the Class.")
(domainSubclass ClassToSetFn 1 Class)
(instance ClassToSetFn TotalValuedRelation)
(instance ClassToSetFn UnaryFunction)
(range ClassToSetFn Set)

(<=>
  (element ?INSTANCE (ClassToSetFn ?CLASS))
  (instance ?INSTANCE ?CLASS))
        
;; All patients of deciding are sets corresponding to classes of intentional processes.
(=>
  (and
    (instance ?DECIDE Deciding)
    (patient ?DECIDE ?OPTIONSET))
  (exists (?CLASS)
    (and
      (equal (ClassToSetFn ?CLASS) ?OPTIONSET)
      (subclass ?CLASS IntentionalProcess))))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (patient ?DECIDE (ClassToSetFn ?OPTION)))
  (believes ?AGENT
    (capability ?OPTION agent ?AGENT)))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (result ?DECIDE (ClassToSetFn ?DECISION)))
  (believes ?AGENT
    (holdsDuring
      (FutureFn
        (WhenFn ?DECIDE))
      (exists (?P)
        (and
          (instance ?P ?DECISION)
          (agent ?P ?AGENT)
          (earlier
            (WhenFn ?DECIDE)
            (WhenFn ?P)))))))


;; And the 'alternative' set of classes approach to make it easier to find and reference.
;; Suppose we go with the idea to represent the set of options in a decision in terms of a set.
;; Then we want to say that all the elements thereof are intentional processes.                                      
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;   (subclass ?O IntentionalProcess))

;; For every instance of deciding, there is a non-empty set over which one is deciding.
; (=>
;   (instance ?DECIDE Deciding)
;   (exists (?S)
;     (and
;       (instance ?S NonNullSet)
;       (patient ?DECIDE ?S))))

;; For every option in a decision set for an agent,
;; the agent believes itself capable of performing this option.   
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;     (believes ?AGENT 
;       (capability ?O agent ?AGENT)))

;;  For every resulting decision set element, the agent believes it will enact that behavior in the future.  
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set)
;     (element ?O ?S))
;   (believes ?AGENT
;     (holdsDuring 
;       (FutureFn
;         (WhenFn ?DECIDE))
;       (exists (?P)
;         (and
;           (instance ?P ?O)
;           (agent ?P ?AGENT))))))

;; The resulting decision-set is a subset of some decision set being decided over.       
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set))
;   (exists (?S)
;     (and
;       (patient ?DECISION ?S)
;       (subset ?DECISION ?S))))

;; This should ontologically work for the Virtue ethics case without providing a specific measure.
(documentation similar EnglishLanguage "The predicate similar attempts to capture the ontologic notion of similarity 
from a subjective point of view. (similar ?A ?E1 ?E2) means that ?E1 and ?E2 are similar to cognitive agent ?A.")
(instance similar TernaryPredicate)  
(domain similar 1 CognitiveAgent)
(domain similar 2 Entity)
(domain similar 3 Entity)

(=>
  (similar ?A ?E1 ?E2)
  (forall (?J1 ?J2 ?O1 ?O2)
    (=>
      (and
        (instance ?J1 Judging)
        (instance ?O1 Formula)
        (agent ?J1 ?A)
        (patient ?J1 ?E1)
        (result ?J1 ?O1)
        (instance ?J2 Judging)
        (instance ?O2 Formula)
        (agent ?J2 ?A)
        (patient ?J2 ?E2)
        (result ?J2 ?O2))
      (modalAttribute
        (similar ?A ?O1 ?O2) Likely))))

;; This might help.
(=>
  (equal ?E1 ?E2)
  (forall (?A)
    (similar ?A ?E1 ?E2)))

(<=>
  (similar ?A ?E1 ?E2)
  (similar ?A ?E2 ?E1))

(documentation Deontology EnglishLanguage "Deontology is the ethical paradigm that judges the morality of an action 
based on the action adheres to a set of rules and principles.")
(subclass Deontology Ethics)

(documentation Utilitarianism EnglishLanguage "Utilitarianism is the ethical paradigm that judges the morality of an action 
based on whether it maximizes the good over the bad, which is typically determined via a utility function.")
(subclass Utilitarianism Ethics)

(documentation VirtueEthics EngnlishLanguage "Virtue ethics is the ethical paradigm that judges the morality of an action 
based on the character of the agent performing an action.  A virtuous agent is one who possesses virtues.  
'An action is right if and only if it is what a virtuous agent would characteristically (i.e., acting in caharacter) 
do in the circumstances' (On Virtue Ethics -- Right Action).")
(subclass VirtueEthics Ethics)

(documentation HedonisticUtilitarianism EnglishLanguage "Hedonistic Utilitarianism is a form of utilitarianism that focuses on maximizing pleasure and minimizing pain in evaluating the moral value of an action.")
(subclass HedonisticUtilitarianism Utilitarianism)

(documentation Consequentialism EnglishLanguage "Consequentialism is a moral theory that holds that 'whether an act is morally right depends only on consequences (as opposed to the circumstances or the intrinsic nature of the act or anything that happens before the act)' (Stanford Encyclopedia of Philosophy).")
(subclass Consequentialism Utilitarianism)

(documentation MoralAttribute EnglishLanguage "Moral Attributes are a subcass of Normative Attributes intended to denote whether something is Good, Bad, Right, Wrong, Virtuous, Viceful, or other moral attributes.")
(subclass MoralAttribute NormativeAttribute)

(instance MorallyGood MoralAttribute)
(instance MorallyBad MoralAttribute)

(subclass VirtueAttribute MoralAttribute)
(subclass ViceAttribute MoralAttribute)

(subclass VirtueAttribute PsychologicalAttribute)
(subclass ViceAttribute PsychologicalAttribute)

;; Do we want a moral attribute for utilitarianism?

;; Generally speaking, yes.  Might some paraconsistency reign?  :- p
(contraryAttribute MorallyGood MorallyBad)
(contraryAttribute VirtueAttribute ViceAtribute)

(documentation VirtuousAgent EnglishLanguage "'A virtuous agent is one who has, and exercises, certain character traits, namely, the virtues.' (On Virtue Ethics)")
(subclass VirtuousAgent AutonomousAgent)

;; Draft 3: Note that it is quantifying over all virtues!  
;; A very strong requirement for a virtuous agent, lol.
(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VIRTUE VirtueAttribute)
    (attribute ?AGENT ?VIRTUE))
  (instance ?AGENT VirtuousAgent))

;; Draft 4: This version seems better: an agent posessing a virtue increases the likelihood that the agent is virtuous ;- ).
(increasesLikelihood
  (exists (?VIRTUE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VIRTUE VirtueAttribute)
      (attribute ?AGENT ?VIRTUE)))
  (instance ?AGENT VirtuousAgent))
  
(=>
  (instance ?AGENT VirtuousAgent)
  (exists (?VIRTUE)
    (attribute ?AGENT ?VIRTUE)))
  
(documentation ViciousAgent EnglishLanguage "A vicious agent is one who has, and exercises, certain character traits, namely, the vices.  The antonym of VirtuousAgent.")
(subclass ViciousAgent AutonomousAgent)

(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VICE ViceAttribute)
    (attribute ?AGENT ?VICE))
  (instance ?AGENT ViciousAgent))
  
(increasesLikelihood
  (exists (?VICE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VICE ViceAttribute)
      (attribute ?AGENT ?VICE)))
  (instance ?AGENT ViciousAgent))
  
(=>
  (instance ?AGENT ViciousAgent)
  (exists (?VICE)
    (attribute ?AGENT ?VICE)))

;; Encapsulate the Autonomous Agent aspect of "behavior"-type processes.
(documentation AutonomousAgentProcess EnglishLanguage "AgentProcess is the Class of all Processes in which there is an autonomous agent.")
(subclass AutonomousAgentProcess Process)
(subclass BodyMotion AutonomousAgentProcess)
(subclass Vocalizing AutonomousAgentProcess)

(=>
  (instance ?PROC AutonomousAgentProcess)
  (exists (?AGENT)
    (and
      (agent ?PROC ?AGENT)
      (instance ?AGENT AutonomousAgent))))

;; A theory is a set of sentences (in a formal language).
(documentation Theory EnglishLanguage "A set of sentences.")
(subclass Theory Set)

(<=>
  (instance ?T Theory)
  (forall (?S)
    (=>
      (element ?S ?T)
      (instance ?S Sentence))))

(documentation MoralTheory EnglishLanguage "A set of sentences in a moral theory")
(subclass MoralTheory Theory)

;; Insert rules
;; I'm tempted to partition it but that's crude as there is at least one paradigm I haven't covered (morally nihilistic theories).

;; Maybe I should have a "theory of type X" predicate instead but this seems cleaner.
(documentation MoralSentence EnglishLanguage "A sentence of a moral theory")
(subclass MoralSentence Sentence)

(<=>
  (instance ?SENTENCE MoralSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY MoralTheory)
      (element ?SENTENCE ?THEORY))))
      
(documentation DeontologicalTheory EnglishLanguage "A set of sentences assigning moral attributes.")
(subclass DeontologicalTheory MoralTheory)

;; A deontological theory is one where for every sentence, there exists a formula and moral attribute 
;; such that the sentence assigns this  moral attribute to the formula.
(<=>
  (instance ?D DeontologicalTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (exists (?F ?MORALATTRIBUTE)
        (and
          (equal ?S
            (modalAttribute ?F ?MORALATTRIBUTE))
          (instance ?F Formula)
          (or
            (equal ?MORALATTRIBUTE MorallyGood)
            (equal ?MORALATTRIBUTE MorallyBad)))))))
    
(documentation VirtueEthicsTheory EnglishLanguage "A set of sentences assigning virtue or vice attributes.")
(subclass VirtueEthicsTheory MoralTheory)
                    
(<=>
  (instance ?V VirtueEthicsTheory)
  (forall (?S)
    (=>
      (element ?S ?V)
      (exists (?AGENT ?VIRTUE)
        (and
          (equal ?S
            (attribute ?AGENT ?VIRTUE))
          (instance ?AGENT AutonomousAgent)
          (or
            (instance ?VIRTUE VirtueAttribute)
            (instance ?VIRTUE ViceAttribute)))))))
            
(documentation UtilitarianTheory EnglishLanguage "A set of sentences dealing with the utility of behaviors.")
(subclass UtilitarianTheory MoralTheory)

(<=>
  (instance ?U UtilitarianTheory)
  (forall (?S)
    (=>
      (element ?S ?U)
      (exists (?CBEHAVE ?CBEHAVE2 ?N ?C)
        (and
          (subclass ?CBEHAVE AutonomousAgentProcess)
          (subclass ?CBEHAVE2 AutonomousAgentProcess)
          (or
            (equal ?S
              (
                (?C
                  (UtilitySubclassFn ?CBEHAVE) ?N)))
            (equal ?S
              (?C
                (UtilitySubclassFn ?CBEHAVE)
                (UtilitySubclassFn ?CBEHAVE2))))
          (instance ?N Number)
          (or
            (equal ?C greaterThan)
            (equal ?C lessThan)
            (equal ?C greaterThanOrEqualTo)
            (equal ?C lessThanOrEqualTo)
            (equal ?C equal)))))))

;; This is actually really clean.  No mucking around in saying that it is judging behavioral (instances or classes), etc.
(documentation MoralJudging EnglishLanguage "A subclass of Judging where the proposition believed is 
a moral sentence from a moral theory (in a given paradigm).")
(subclass MoralJudging Judging)

(=>
  (instance ?JUDGE MoralJudging)
  (exists (?SENTENCE)
    (and
      (instance ?SENTENCE MoralSentence)
      (result ?JUDGE ?SENTENCE))))

(documentation Ethics EnglishLanguage "Ethics is the normative science of the conduct of human beings living in society, 
which judges this conduct to be right or wrong, to be good or bad, or in some similar way. (An Introduction to Ethics (LIllie, 1948))")
(subclass Ethics Philosophy)
(subclass Ethics Science) 

(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging))
;; The reference definition includes judging (and normativity), so referring to the theory w/o judging/interpreting the theory is
;; "Necessary but not sufficient".
(and
  (refers Ethics ?THEORY)
  (instance ?THEORY MoralTheory))
  
;; Ethics refers to the judgment by a group of a member via a moral sentence (that refers to the member).
;; It gets a bit vague abstracting out behavior, lol.    
(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging)
  (instance ?GROUP Group)
  (agent ?JUDGE ?AGENT)
  (or
    (member ?AGENT ?GROUP)
    (part ?AGENT ?GROUP))
  (member ?MEMB ?GROUP)
  (patient ?JUDGE ?SENTENCE)
  (instance ?SENTENCE MoralSentence)
  (refers ?SENTENCE ?MEMB))

(documentation MoralNihilism EnglishLanguage "'Moral Nihilism is the view that nothing is morally wrong' (SEP - Moral Skepticism). 
Moral Nihilism can also be defined as 'the view that there are no moral facts' (Ethics: The Fundamentals).")
(subclass MoralNihilism Ethics)
  
(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?MORALSTATEMENT)
            (and
              (instance ?MORALSTATEMENT MoralSentence)
              (instance ?MORALSTATEMENT Fact))))))))

(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?BEHAVIORCLASS)
            (and
              (subclass ?BEHAVIORCLASS AutonomousAgentProcess)
              (modalAttribute
                (exists (?BEHAVIORINSTANCE)
                  (instance ?BEHAVIORINSTANCE ?BEHAVIORCLASS)) MorallyWrong))))))))
                          
                    
                                            