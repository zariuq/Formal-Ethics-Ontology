;; I'll start with the latest version of Deciding
;; Note that this is a philosophical draft, #4

;; It seems helpful to have a wrapper for classes that allows them to be treated as instances.
;; Sort of an inverse of the KappaFn?  -- I think for the reverse direction, KappaFn should be used.
;; I would wish to define a subclass of Set for Sets of Instances to make the type checking easier.
(documentation ClassToSetFn EnglishLanguage "A UnaryFunction that maps a Class into the set of instances of the Class.")
(domainSubclass ClassToSetFn 1 Class)
(instance ClassToSetFn TotalValuedRelation)
(instance ClassToSetFn UnaryFunction)
(range ClassToSetFn Set)

(<=>
  (element ?INSTANCE (ClassToSetFn ?CLASS))
  (instance ?INSTANCE ?CLASS))
        
;; All patients of deciding are sets corresponding to classes of intentional processes.
(=>
  (and
    (instance ?DECIDE Deciding)
    (patient ?DECIDE ?OPTIONSET))
  (exists (?CLASS)
    (and
      (equal (ClassToSetFn ?CLASS) ?OPTIONSET)
      (subclass ?CLASS IntentionalProcess))))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (patient ?DECIDE (ClassToSetFn ?OPTION)))
  (believes ?AGENT
    (capability ?OPTION agent ?AGENT)))

(=>
  (and
    (instance ?DECIDE Deciding)
    (agent ?DECIDE ?AGENT)
    (result ?DECIDE (ClassToSetFn ?DECISION)))
  (believes ?AGENT
    (holdsDuring
      (FutureFn
        (WhenFn ?DECIDE))
      (exists (?P)
        (and
          (instance ?P ?DECISION)
          (agent ?P ?AGENT)
          (earlier
            (WhenFn ?DECIDE)
            (WhenFn ?P)))))))


;; And the 'alternative' set of classes approach to make it easier to find and reference.
;; Suppose we go with the idea to represent the set of options in a decision in terms of a set.
;; Then we want to say that all the elements thereof are intentional processes.                                      
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;   (subclass ?O IntentionalProcess))

;; For every instance of deciding, there is a non-empty set over which one is deciding.
; (=>
;   (instance ?DECIDE Deciding)
;   (exists (?S)
;     (and
;       (instance ?S NonNullSet)
;       (patient ?DECIDE ?S))))

;; For every option in a decision set for an agent,
;; the agent believes itself capable of performing this option.   
; (=>
;   (and
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (instance ?S Set)
;     (patient ?DECIDE ?S)
;     (element ?O ?S))
;     (believes ?AGENT 
;       (capability ?O agent ?AGENT)))

;;  For every resulting decision set element, the agent believes it will enact that behavior in the future.  
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (agent ?DECIDE ?AGENT)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set)
;     (element ?O ?S))
;   (believes ?AGENT
;     (holdsDuring 
;       (FutureFn
;         (WhenFn ?DECIDE))
;       (exists (?P)
;         (and
;           (instance ?P ?O)
;           (agent ?P ?AGENT))))))

;; The resulting decision-set is a subset of some decision set being decided over.       
; (=>
;   (and 
;     (instance ?DECIDE Deciding)
;     (result ?DECIDE ?DECISION)
;     (instance ?DECISION Set))
;   (exists (?S)
;     (and
;       (patient ?DECISION ?S)
;       (subset ?DECISION ?S))))

;; This should ontologically work for the Virtue ethics case without providing a specific measure.
(documentation similar EnglishLanguage "The predicate similar attempts to capture the ontologic notion of similarity 
from a subjective point of view. (similar ?A ?E1 ?E2) means that ?E1 and ?E2 are similar to cognitive agent ?A.")
(instance similar TernaryPredicate)  
(domain similar 1 CognitiveAgent)
(domain similar 2 Entity)
(domain similar 3 Entity)

(=>
  (similar ?A ?E1 ?E2)
  (forall (?J1 ?J2 ?O1 ?O2)
    (=>
      (and
        (instance ?J1 Judging)
        (instance ?O1 Formula)
        (agent ?J1 ?A)
        (patient ?J1 ?E1)
        (result ?J1 ?O1)
        (instance ?J2 Judging)
        (instance ?O2 Formula)
        (agent ?J2 ?A)
        (patient ?J2 ?E2)
        (result ?J2 ?O2))
      (modalAttribute
        (similar ?A ?O1 ?O2) Likely))))

;; This might help.
(=>
  (equal ?E1 ?E2)
  (forall (?A)
    (similar ?A ?E1 ?E2)))

(<=>
  (similar ?A ?E1 ?E2)
  (similar ?A ?E2 ?E1))

;; Not sure if this should be subjective or not!
(documentation relevant EnglishLanguage "The predicate relevant attempts to ontologically represent the notion of 
an entity ?E1 being relevant to ?E2: (relevant ?E1 ?E2). Relevant: having a bearing on or connection with the 
subject at issue; 'the scientist corresponds with colleagues in order to learn about matters relevant to her 
own research'.")
(instance relevant BinaryPredicate)  
(domain relevant 1 Entity)
(domain relevant 2 Entity)

;; The patient of a process is relevant to the process.
(=>
  (and
    (instance ?E2 Process)
    (patient ?E2 ?E1))
  (relevant ?E1 ?E2))

;; If an Object plays some role in a Process, then it is relevant to the process.
(=> 
  (and
    (instance ?E1 Object)
    (instance ?E2 Process)
    (exists (?ROLE)
      (playsRoleInEvent ?E1 ?ROLE ?E2)))
  (relevant ?E1 ?E2))

(=> 
  (and 
    (instance ?E1 Object)
    (instance ?E2 Process)
    (eventLocated ?E2 ?E1))
  (relevant ?E1 ?E2))

;; This isn't a case role, so  it's distinct ;- ).
;; Partly located may be too strong yet let's be general, eh, bruh?  
(=> 
  (and 
    (instance ?E1 Physical)
    (instance ?E2 Process)
    (partlyLocated ?E2 ?E1))
  (relevant ?E1 ?E2))

(documentation Situation EnglishLanguage "A spatiotemporal situation in which something occurs or exists.")
(subclass Situation Physical)

;; I guess this is already there in that WhenFn can be applied to any Physical entity?
;; Basically for every situation, there is a time and place of the situation 😎.
(=>
  (instance ?S Situation)
  (exists (?T)
    (equal ?T (WhenFn ?S))))
    
(=> 
  (instance ?S Situation)
  (exists (?L)
    (equal ?L (WhereFn ?S (BeginFn (WhenFn ?S))))))

;; Probably too storng
;; For every situation, the location of the beginning and end of the time interval of the situation is the same.
(=>
  (and
    (instance ?S Situation)
    (equal ?T
      (WhenFn ?S)))
  (equal
    (WhereFn ?S
      (BeginFn ?T))
    (WhereFn ?S
      (EndFn ?T))))

(documentation capableInSituation EnglishLanguage "(capableInSituation ?TYPE ?ROLE ?OBJECT ?SITUATION) 
means that ?OBJECT has the ability to play the CaseRole ?ROLE in Processes of ?TYPE in ?SITUATION.")
(domainSubclass capableInSituation 1 Process)
(domain capableInSituation 2 CaseRole)
(domain capableInSituation 3 Object)
(domain capableInSituation 4 Situation)
(instance capableInSituation QuaternaryPredicate)

(<=>
  (and
    (capableInSituation ?TYPE ?ROLE ?OBJECT ?SITUATION)
    (instance ?TIME ?TIMEINT)
    (equal ?TIME
      (WhenFn ?SITUATION))
    (equal ?LOCATION
      (WhereFn ?SITUATION
        (BeginFn ?TIME))))
  (and
    (capabilityDuring ?TYPE ?ROLE ?OBJECT ?TIMEINT)
    (capabilityAtLocation ?TYPE ?ROLE ?OBJECT ?LOCATION)))

;; Now maybe I want a SituationFn that given some physical entity returns the situation?
;; Yeah, this is a fabulous catch-all!
(documentation SituationFn EnglishLanguage "Maps a Physical Entity to its Situation.  May be non-deterministic 
because situations have one enduring region whereas a process could cover multiple regions.")
(domain SituationFn 1 Physical)
(range SituationFn Situation)
(instance SituationFn UnaryFunction)
(instance SituationFn TotalValuedRelation)
(relatedInternalConcept SituationFn WhereFn)
(relatedInternalConcept SituationFn WhenFn)

;; The situation of a physical entity spatiotemporally contains the physical entity.
;; Self-commentary: how to quantify this seems tricky, actually.
;; I'm just assigning names to the time and place.
;; For all vars ?TS, this holds?  It's more that for all vars ?TS, if the var is equal to the time, then this holds.
;; Or I want to say that there exists a var ?TS such that it's e qual to the time and this holds?
(=>
  (equal ?SITUATION (SituationFn ?PHYSICAL))
  (exists (?TS ?TP ?LS ?LP)
    (and
      (equal ?TS (WhenFn ?SITUATION))
      (equal ?TP (WhenFn ?PHYSICAL))
      (temporalPart ?TP ?TS)
      (equal ?LS (WhereFn ?SITUATION ?TS))
      (equal ?LP (WhereFn ?PHYSICAL ?TP))
      (part ?LP ?LS))))

;; What if I wish to say that the situation is the minimal spatiotemporally containing physical entity.
;; So for all physical entities, if they contain this physical entity, then either the situation is a proper part of it
;; or it is equal to the situation?
;; Or I could say that there does not exist a physical entity that contains the physical entity which is a proper part of the situation.
;; But then I'll just get that the situation is the physical entity, lol.
;; Well, I need to add some additional property to confound this 😏.
;; ... I kind of wish to say that there is no physical entity satisfying the properties of a situation aside from the one given by this function.
;; An idea could be:
;; 1) SituationToPhysicalFn that gives all physical entities that are in a situation
;; 2) SituationFn that gives the minimal situation for a physical entity.
;; This way with (1) I could specify the general properties.
;; For now, I'll leave the minimality constraints out.
;; (=>
;;   (equal ?SITUATION (SituationFn ?PHYSICAL))
;;   (not
;;     (exists (?PHYS)
;;       (and
;;         (equal ?TS (WhenFn ?PHYS))
;;         (equal ?TP (WhenFn ?PHYSICAL))
;;         (temporalPart ?TP ?TS)
;;         (equal ?LS (WhereFn ?PHYS ?TS))
;;         (equal ?LP (WhereFn ?PHYSICAL ?TP))
;;         (part ?LP ?S)
;;         (properPart ?PHYS ?SITUATION)))))

;; Instead of relevance, let's say that the situation contains everything nearby if the physical entity is an object.
;; I won't use the situation of the nearby entities because this would introduce transitivity.
(=>
  (and
    (equal ?SITUATION (SituationFn ?PHYSICAL))
    (instance ?PHYSICAL Object))
  (forall (?NEAR)
    (=>
      (orientation ?NEAR ?PHYSICAL Near)
      (exists (?TS ?TR ?LS ?LR)
        (and
          (equal ?TS (WhenFn ?SITUATION))
          (equal ?TR (WhenFn ?NEAR))
          (temporalPart ?TR ?TS)
          (equal ?LS (WhereFn ?SITUATION ?TS))
          (equal ?LR (WhereFn ?NEAR ?TR))
          (part ?LR ?LS))))))   

;; If the physical entity is a process that has an agent, then everything near the agent is included in the situation.      
(=>
  (and
    (equal ?SITUATION (SituationFn ?PHYSICAL))
    (instance ?PHYSICAL Process)
    (agent ?PHYSICAL ?AGENT))
  (forall (?NEAR)
    (=>
      (orientation ?NEAR ?AGENT Near)
      (exists (?TS ?TR ?LS ?LR)
        (and
          (equal ?TS (WhenFn ?SITUATION))
          (equal ?TR (WhenFn ?NEAR))
          (temporalPart ?TR ?TS)
          (equal ?LS (WhereFn ?SITUATION ?TS))
          (equal ?LR (WhereFn ?NEAR ?TR))
          (part ?LR ?LS))))))
 
;; The situation of a physical entity spatiotemporally contains the situation of everything relevant to the physical entity.
;; Definitely too strong, tbh.  Yet, for now, w/e ;D ;D ;D
(=>
  (equal ?SITUATION (SituationFn ?PHYSICAL))
  (forall (?REL)
    (=>
      (relevant ?REL ?PHYSICAL)     
      (part (SituationFn ?REL) ?SITUATION))))

(documentation SituationFormulaFn EnglishLanguage "Maps a Formula to the Situation it describes or the Situation of what it describes.")  
(domain SituationFormulaFn 1 Formula)
(range SituationFormulaFn Situation)
(instance SituationFormulaFn UnaryFunction)
(instance SituationFormulaFn TotalValuedRelation)
(relatedInternalConcept SituationFormulaFn SituationFn)

;; If a Process realizes a Formula, then the situation of the formula is the situation of the process.
(=>
  (and
    (equal ?SITUATION (SituationFormulaFn ?FORMULA))
    (realizesFormula ?PROCESS ?FORMULA))
  (equal ?SITUATION (SituationFn ?PROCESS)))

;; The same for Objects and conforms.
(=>
  (and
    (equal ?SITUATION (SituationFormulaFn ?FORMULA))
    (conformsFormula ?OBJECT ?FORMULA))
  (equal ?SITUATION (SituationFn ?OBJECT)))

;; And let's say the same for represents in general
(=>
  (and
    (equal ?SITUATION (SituationFormulaFn ?FORMULA))
    (represents ?PHYSICAL ?FORMULA)
    (instance ?PHYSICAL Physical))
  (equal ?SITUATION (SituationFn ?PHYSICAL)))

;; If there is a Situation of something Physical that represents a Formula,
;; Then the Situation is also of the formula!
;; Maybe this should let me use Situation over formulas... as I'm sort of doing that for ease now... :'- ).
(=> 
  (and 
    (equal ?SITUATION (SituationFn ?PHYSICAL))
    (represents ?PHYSICAL ?FORMULA)
    (instance ?PHYSICAL Physical)
    (instance ?FORMULA Formula))
  (equal ?SITUATION (SituationFormulaFn ?FORMULA)))
  
;; An alternative way to frame things:

(forall (?PROCESS ?FORMULA)
  (=>
    (realizesFormula ?PROCESS ?FORMULA)
    (equal (SituationFn ?PROCESS) (SituationFormulaFn ?FORMULA))))

(documentation MoralAttribute EnglishLanguage "Moral Attributes are a subclass of Normative Attributes intended to denote whether something is Good, Bad, Right, Wrong, Virtuous, Viceful, or other moral attributes.")
(subclass MoralAttribute NormativeAttribute)

(documentation MoralValueAttribute EnglishLanguage "Moral Value Attributes are a subclass of Moral Attributes dealing with the attribution of value: whether something is good, bad, or netural.")
(subclass MoralValueAttribute MoralAttribute)

(instance MorallyGood MoralValueAttribute)
(instance MorallyBad MoralValueAttribute)
(instance MorallyNeutral MoralValueAttribute)

(documentation MoralVirtueAttribute EnglishLanguage "Moral Virtue Attributes are a subclass of Moral Attributes dealing with the virtues and vices.")
(subclass MoralVirtueAttribute MoralAttribute)

(subclass VirtueAttribute MoralVirtueAttribute)
(subclass ViceAttribute MoralVirtueAttribute)

(subclass VirtueAttribute PsychologicalAttribute)
(subclass ViceAttribute PsychologicalAttribute)

;; Do we want a moral attribute for utilitarianism?

;; Generally speaking, yes.  Might some paraconsistency reign?  :- p
(contraryAttribute MorallyGood MorallyBad)
(contraryAttribute MorallyGood MorallyNeutral)
(contraryAttribute MorallyBad MorallyNeutral)
(contraryAttribute VirtueAttribute ViceAtribute) 

;; Why not say it explicitly, too.  
(=>
  (modalAttribute ?F MorallyGood)
  (not (modalAttribute ?F MorallyBad)))
  
(=>
  (modalAttribute ?F MorallyGood)
  (not (modalAttribute ?F MorallyNeutral)))
  
(=>
  (modalAttribute ?F MorallyBad)
  (not (modalAttribute ?F MorallyGood)))
  
(=>
  (modalAttribute ?F MorallyBad)
  (not (modalAttribute ?F MorallyNeutral)))
  
(=>
  (modalAttribute ?F MorallyNeutral)
  (not (modalAttribute ?F MorallyGood)))
  
(=>
  (modalAttribute ?F MorallyNeutral)
  (not (modalAttribute ?F MorallyBad)))

(documentation VirtuousAgent EnglishLanguage "'A virtuous agent is one who has, and exercises, certain character traits, namely, the virtues.' (On Virtue Ethics)")
(subclass VirtuousAgent AutonomousAgent)

;; Draft 3: Note that it is quantifying over all virtues!  
;; A very strong requirement for a virtuous agent, lol.
(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VIRTUE VirtueAttribute)
    (attribute ?AGENT ?VIRTUE))
  (instance ?AGENT VirtuousAgent))

;; Draft 4: This version seems better: an agent posessing a virtue increases the likelihood that the agent is virtuous ;- ).
(increasesLikelihood
  (exists (?VIRTUE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VIRTUE VirtueAttribute)
      (attribute ?AGENT ?VIRTUE)))
  (instance ?AGENT VirtuousAgent))
  
(=>
  (instance ?AGENT VirtuousAgent)
  (exists (?VIRTUE)
    (attribute ?AGENT ?VIRTUE)))
  
(documentation ViciousAgent EnglishLanguage "A vicious agent is one who has, and exercises, certain character traits, namely, the vices.  The antonym of VirtuousAgent.")
(subclass ViciousAgent AutonomousAgent)

(=>
  (and
    (instance ?AGENT AutonomousAgent)
    (instance ?VICE ViceAttribute)
    (attribute ?AGENT ?VICE))
  (instance ?AGENT ViciousAgent))
  
(increasesLikelihood
  (exists (?VICE)
    (and
      (instance ?AGENT AutonomousAgent)
      (instance ?VICE ViceAttribute)
      (attribute ?AGENT ?VICE)))
  (instance ?AGENT ViciousAgent))
  
(=>
  (instance ?AGENT ViciousAgent)
  (exists (?VICE)
    (attribute ?AGENT ?VICE)))

;; Encapsulate the Autonomous Agent aspect of "behavior"-type processes.
(documentation AutonomousAgentProcess EnglishLanguage "AgentProcess is the Class of all Processes in which there is an autonomous agent.")
(subclass AutonomousAgentProcess Process)
(subclass BodyMotion AutonomousAgentProcess)
(subclass Vocalizing AutonomousAgentProcess)

(=>
  (instance ?PROC AutonomousAgentProcess)
  (exists (?AGENT)
    (and
      (agent ?PROC ?AGENT)
      (instance ?AGENT AutonomousAgent))))

;; A theory is a set of sentences (in a formal language).
(documentation Theory EnglishLanguage "A set of sentences.")
(subclass Theory Set)

(<=>
  (instance ?T Theory)
  (forall (?S)
    (=>
      (element ?S ?T)
      (instance ?S Sentence))))

;; Maybe I should change all the sentences to Formulas
(documentation SentenceList EnglishLanguage "A list of Sentences.")
(subclass SentenceList List)

(=>
  (and
    (instance ?LIST SentenceList)
    (inList ?SENTENCE ?LIST))
  (instance ?SENTENCE Sentence))

(documentation ListAndFn EnglishLanguage "The and-concatenation of all the sentences in a SentenceList.")
(domain ListAndFn 1 SentenceList)
(instance ListAndFn UnaryFunction)
(range ListAndFn Sentence)

(=>
  (and
    (equal ?S
      (ListAndFn ?L))
    (equal 1
      (ListLengthFn ?L)))
  (equal ?S
    (ListOrderFn ?L 1)))

(=>
  (and
    (equal ?S
      (ListAndFn ?L))
    (greaterThan
      (ListLengthFn ?L) 1))
  (equal ?S
    (and
      (FirstFn ?L)
      (ListAndFn
        (SubListFn 2
          (ListLengthFn ?L) ?L)))))

(documentation SetToListFn EnglishLanguage "A function that converts a set into a list.  The order is unspecified.")
(instance SetToListFn UnaryFunction)
(domain SetToListFn 1 Set)
(range SetToListFn List)

;; If StL(S) = L, then S and L share all their members and their sizes are equal.
;; This says nothing about the order.
(=>
  (equal
    (SetToListFn ?SET) ?LIST)
  (and
    (equal
      (ListLengthFn ?LIST)
      (CardinalityFn ?SET))
    (forall (?ELEMENT)
      (<=>
        (element ?ELEMENT ?SET)
        (inList ?ELEMENT ?LIST)))))

(documentation MoralTheory EnglishLanguage "A set of sentences in a moral theory")
(subclass MoralTheory Theory)

;; Insert rules
;; I'm tempted to partition it but that's crude as there is at least one paradigm I haven't covered (morally nihilistic theories).

;; Maybe I should have a "theory of type X" predicate instead but this seems cleaner.
(documentation MoralSentence EnglishLanguage "A sentence of a moral theory")
(subclass MoralSentence Sentence)

(<=>
  (instance ?SENTENCE MoralSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY MoralTheory)
      (element ?SENTENCE ?THEORY))))

(documentation DeontologicalTheory EnglishLanguage "A set of sentences assigning moral attributes.")
(subclass DeontologicalTheory MoralTheory)

(documentation DeontologicalSentence EnglishLanguage "A sentence of a deontological language/theory.")      
(subclass DeontologicalSentence MoralSentence)

(<=>
  (instance ?SENTENCE DeontologicalSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY DeontologicalTheory)
      (element ?SENTENCE ?THEORY))))


(documentation ValueJudgmentSentence EnglishLanguage "A sentence that describes the attribution of a moral value judgment.")      
(subclass ValueJudgmentSentence MoralSentence)

(documentation SimpleValueJudgmentSentence EnglishLanguage "A sentence that describes the attribution of a moral value judgment.")      
(subclass SimpleValueJudgmentSentence ValueJudgmentSentence)

(<=>
  (instance ?SENTENCE SimpleValueJudgmentSentence)
  (exists (?F ?MORALATTRIBUTE)
    (and
      (equal (modalAttribute ?F ?MORALATTRIBUTE) ?SENTENCE)
      (instance ?F Formula)
      (or
        (equal ?MORALATTRIBUTE MorallyGood)
        (equal ?MORALATTRIBUTE MorallyBad)
        (equal ?MORALATTRIBUTE MorallyNeutral)))))

;; So now that I defined MoralValueAttribute, this can be simplified!        
(<=>
  (instance ?SENTENCE SimpleValueJudgmentSentence)
  (exists (?F ?MORALATTRIBUTE)
    (and
      (equal (modalAttribute ?F ?MORALATTRIBUTE) ?SENTENCE)
      (instance ?F Formula)
      (instance ?MORALATTRIBUTE MoralValueAttribute))))

;; The definition of ethics is that it focuses on judging actions.
(documentation SimpleActionValueJudgmentSentence EnglishLanguage "A sentence that describes the attribution of a moral value judgment to an action.")      
(subclass SimpleActionValueJudgmentSentence SimpleValueJudgmentSentence)

(<=>
  (instance ?SENTENCE SimpleActionValueJudgmentSentence)
  (exists (?CLASS ?FORMULA ?MORALATTRIBUTE)
    (and 
      (equal ?SENTENCE (modalAttribute ?FORMULA ?MORALATTRIBUTE))
      (equal ?FORMULA 
        (exists (?PROC)
          (instance ?PROC ?CLASS)))
      (subclass ?CLASS AutonomousAgentProcess))))

(<=>
  (instance ?SENTENCE ValueJudgmentSentence)
  (exists (?VJS)
    (and
      (instance ?VJS SimpleValueJudgmentSentence)
      (part ?VJS ?SENTENCE))))

(documentation ImperativeSentence EnglishLanguage "A sentence that describes an imperative deontic operator.")      
(subclass ImperativeSentence DeontologicalSentence)    

(documentation SimpleImperativeSentence EnglishLanguage "A sentence that describes an imperative deontic operator.")      
(subclass SimpleImperativeSentence ImperativeSentence)

(<=>
  (instance ?SENTENCE SimpleImperativeSentence)
  (exists (?F ?DEONTICATTRIBUTE)
        (and
          (equal (modalAttribute ?F ?DEONTICATTRIBUTE) ?SENTENCE)
          (instance ?F Formula)
          (instance ?DEONTICATTRIBUTE DeonticAttribute))))

(<=>
  (instance ?SENTENCE ImperativeSentence)
  (exists (?IT)
    (and
      (instance ?IT SimpleImperativeSentence)
      (part ?IT ?SENTENCE))))

(documentation ValueJudgmentTheory EnglishLanguage "A set of sentences assigning moral attributes.")
(subclass ValueJudgmentTheory MoralTheory)

;; A deontological theory is one where for every sentence, there exists a formula and moral attribute 
;; such that the sentence assigns this  moral attribute to the formula.
;;  I think the inverse direction works for the Virtue and Utilitarian approaches as we're not quantifying over general formulas.
;; Yet I am not fully sure how I wish to constrain formulas.
;; Existential formulas over processes or physical entities or... what?
(=>
  (instance ?D ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (exists (?F ?MORALATTRIBUTE)
        (and
          (equal ?S
            (modalAttribute ?F ?MORALATTRIBUTE))
          (instance ?F Formula)
          (or
            (equal ?MORALATTRIBUTE MorallyGood)
            (equal ?MORALATTRIBUTE MorallyBad)))))))

;; The above is too strong.  The sentence may describe the context in which the moral judgment is being dished out.
(=>
  (instance ?D ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (exists (?F ?MORALATTRIBUTE)
        (and
          (part (modalAttribute ?F ?MORALATTRIBUTE) ?S)
          (instance ?F Formula)
          (or
            (equal ?MORALATTRIBUTE MorallyGood)
            (equal ?MORALATTRIBUTE MorallyBad)
            (equal ?MORALATTRIBUTE MorallyNeutral)))))))

;; Now I can simplify things and say that a Deontological Value Judgment Theory is one in which all sentences contain a value judgment sentence as a part!
(=>
  (instance ?D ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?D)
      (instance ?S ValueJudgmentSentence))))
            
(documentation DeontologicalImperativeTheory EnglishLanguage "A set of sentences containing deontic attributes.")
(subclass DeontologicalImperativeTheory DeontologicalTheory)

(=> 
  (instance ?MT DeontologicalImperativeTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (instance ?S ImperativeSentence))))
 
(documentation VirtueEthicsTheory EnglishLanguage "A set of sentences assigning virtue or vice attributes.")
(subclass VirtueEthicsTheory MoralTheory)

(documentation VirtueEthicsSentence EnglishLanguage "A sentence of a virtue ethics language/theory.")      
(subclass VirtueEthicsSentence MoralSentence)

(<=>
  (instance ?SENTENCE VirtueEthicsSentence)
  (exists (?THEORY)
    (and
      (instance ?THEORY VirtueEthicsTheory)
      (element ?SENTENCE ?THEORY))))

(documentation SimpleVirtueSentence EnglishLanguage "A sentence that describes an virtue/vice attribute assignment to an agent.")      
(subclass SimpleVirtueSentence VirtueEthicsSentence)    

(<=>
  (instance ?SENTENCE SimpleVirtueSentence)
  (exists (?AGENT ?VIRTUEATTRIBUTE)
    (and
      (equal ?SENTENCE (attribute ?AGENT ?VIRTUEATTRIBUTE))
      (instance ?AGENT AutonomousAgent)
      (instance ?VIRTUEATTRIBUTE MoralVirtueAttribute))))

(<=>
  (insance ?SENTENCE VirtueEthicsSentence)
  (exists (?SVS)
    (and
      (instance ?SVS SimpleVirtueSentence)
      (part ?SVS ?SENTENCE))))       

(<=>
  (instance ?V VirtueEthicsTheory)
  (forall (?S)
    (=>
      (element ?S ?V)
      (instance ?S VirtueSentence))))
            
(documentation UtilitarianTheory EnglishLanguage "A set of sentences dealing with the utility of behaviors.")
(subclass UtilitarianTheory MoralTheory)

(documentation UtilitarianSentence EnglishLanguage "A sentence of the variety of a utilitarian theory.")
(subclass UtilitarianSentence MoralSentence)


(documentation UtilityFn EnglishLanguage "A UnaryFunction that maps an instance of AutonomousAgentProcess 
to the net utility it creates.  In the case of hedonistic utilitarianism, this may be (pleasure - pain).")
(subclass UtilityFn TotalValuedRelation)
(subclass UtilityFn UnaryFunction)

(=>
    (instance ?UF UtilityFn)
    (and
        (domain ?UF 1 AutonomousAgentProcess)
        (range ?UF RealNumber)))

(documentation UtilitySubclassFn EnglishLanguage "A UnaryFunction that maps a subclass of AutonomousAgentProcess 
to the net utility it creates.  In the case of hedonistic utilitarianism, this may be (pleasure - pain).  
For the case of classes of behavior, this could be understood as an expectation.")
(subclass UtilitySublassFn TotalValuedRelation)
(subclass UtilitySubclassFn UnaryFunction)

(=>
    (instance ?UF UtilitySubclassFn)
    (and
        (domainSubclass ?UF 1 AutonomousAgentProcess)
        (range ?UF RealNumber)))

(documentation UtilityFormulaFn EnglishLanguage "A UnaryFunction that 
maps Formulas to the net utility of that which is described.  
Typically, the formula should refer to an action.")
(subclass UtilityFormulaFn TotalValuedRelation)
(subclass UtilityFormulaFn UnaryFunction)

(=>
    (instance ?UF UtilityFormulaFn)
    (and
        (domain ?UF 1 Formula)
        (range ?UF RealNumber)))

(documentation SimpleUtilitarianSentence EnglishLanguage "A sentence that assigns or compares the value of situations described by formulas.")      
(subclass SimpleUtilitarianSentence UtilitarianSentence) 

(documentation UtilityAssignmentSentence EnglishLanguage "A Sentence that assigns a (real) number value 
to a situation described by a formula.")
(subclass UtilityAssignmentSentence SimpleUtilitarianSentence)

(<=>
  (instance ?SENTENCE UtilityAssignmentSentence)
  (exists (?FORMULA ?VALUE ?UF)
    (and 
      (equal ?SENTENCE (equal (AssignmentFn ?UF ?FORMULA) ?VALUE))
      (instance ?UF UtilityFormulaFn)
      (instance ?FORMULA Formula)
      (instance ?VALUE Number))))

(documentation UtilityComparisonSentence EnglishLanguage "A sentence that compares the value of 
two situations described by formulas.")
(subclass UtilityComparisonSentence SimpleUtilitarianSentence)

(<=> 
  (instance ?SENTENCE UtilityComparisonSentence)
  (exists (?FORMULA1 ?FORMULA2 ?COMPARATOR ?UF)
    (and
      (instance ?FORMULA1 Formula)
      (instance ?FORMULA2 Formula)
      (instance ?UF UtilityFormulaFn)
      (or
            (equal ?COMPARATOR greaterThan)
            (equal ?COMPARATOR lessThan)
            (equal ?COMPARATOR greaterThanOrEqualTo)
            (equal ?COMPARATOR lessThanOrEqualTo)
            (equal ?COMPARATOR equal))
      (equal ?SENTENCE (AssignmentFn ?COMPARATOR (AssignmentFn ?UF ?FORMULA1) (AssignmentFn ?UF ?FORMULA2))))))

(<=>
  (instance ?SENTENCE SimpleUtilitarianSentence)
  (or
    (instance ?SENTENCE UtilityComparisonSentence)
    (instance ?SENTENCE UtilityAssignmentSentence)))

;; Ultimately, I will wish to weaken this so that this only represents one variety of Utilitarian theory.
(<=>
  (instance ?SENTENCE UtilitarianSentence)
  (exists (?SUS)
    (and 
      (instance ?SUS SimpleUtilitarianSentence)
      (part ?SUS ?SENTENCE))))

(<=> 
  (instance ?U UtilitarianTheory)
  (forall (?S)
    (=>
      (element ?S ?U)
      (instance ?S UtilitarianSentence))))

;; I switched to formulas for consistency with the deontology stuff.
;; This way we might wind up with a different utility function instance for each sentence in the theory.  Heck, why not ;D?
(<=>
  (instance ?U UtilitarianTheory)
  (forall (?S)
    (=>
      (element ?S ?U)
      (exists (?CBEHAVE ?CBEHAVE2 ?N ?C ?UF)
        (and
          (subclass ?CBEHAVE AutonomousAgentProcess)
          (subclass ?CBEHAVE2 AutonomousAgentProcess)
          (instance ?UF UtilitySubclassFn)
          (or
            (equal ?S
              (
                (AssignmentFn?C
                  (AssignmentFn ?UF (ClassToSetFn ?CBEHAVE)) ?N)))
            (equal ?S
              (AssignmentFn ?C
                (AssignmentFn ?UF (ClassToSetFn ?CBEHAVE))
                (AssignmentFn ?UF (ClassToSetFn ?CBEHAVE2)))))
          (instance ?N Number)
          (or
            (equal ?C greaterThan)
            (equal ?C lessThan)
            (equal ?C greaterThanOrEqualTo)
            (equal ?C lessThanOrEqualTo)
            (equal ?C equal)))))))

;; This is actually really clean.  No mucking around in saying that it is judging behavioral (instances or classes), etc.
(documentation MoralJudging EnglishLanguage "A subclass of Judging where the proposition believed is 
a moral sentence from a moral theory (in a given paradigm).")
(subclass MoralJudging Judging)

(=>
  (instance ?JUDGE MoralJudging)
  (exists (?SENTENCE)
    (and
      (instance ?SENTENCE MoralSentence)
      (result ?JUDGE ?SENTENCE))))

(documentation Ethics EnglishLanguage "Ethics is the normative science of the conduct of human beings living in society, 
which judges this conduct to be right or wrong, to be good or bad, or in some similar way. (An Introduction to Ethics (Lillie, 1948))")
(subclass Ethics Philosophy)
(subclass Ethics Science) 

(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging))

;; The reference definition includes judging (and normativity), so referring to the theory w/o judging/interpreting the theory is
;; "Necessary but not sufficient".
(and
  (refers Ethics ?THEORY)
  (instance ?THEORY MoralTheory))

(and
  (refers Ethics MoralJudging)
  (refers Ethics MoralTheory))
  
;; Ethics refers to the judgment by a group of a member via a moral sentence (that refers to the member).
;; It gets a bit vague abstracting out behavior, lol.  
;; Note that the English says that a subCollection is a "proper part", however there is no rule that implies this.  
(and
  (refers Ethics ?JUDGE)
  (instance ?JUDGE MoralJudging)
  (instance ?GROUP Group)
  (agent ?JUDGE ?AGENT)
  (or
    (member ?AGENT ?GROUP)
    (part ?AGENT ?GROUP))
  (member ?MEMB ?GROUP)
  (patient ?JUDGE ?SENTENCE)
  (instance ?SENTENCE MoralSentence)
  (refers ?SENTENCE ?MEMB))

;; Let's get a version that works with moral theories.
;; Ethics refers to a moral theory and a group where each sentence is believed to be true by the group
;; and each sentence refers to a behavior such that it's believed some member of the group is capable of this behavior.
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (and
        (believes ?GROUP ?S)
        (refers ?S (ClassToSetFn ?B))
        (subclass ?B AutonomousAgentProcess)
        (believes ?GROUP
          (exists (?MEMB)
            (and
              (member ?MEMB ?GROUP)
              (capability ?B agent ?MEMB))))))))

;; As this 'belief' is the result of the moral judgment, we can throw moral judgments in.
;; This implies that ?S is believed.
;; However, it also implies that prior to the act of judgment, it was not believed to be so. 
;; Which implies some judgment process by which this moral sentence came to be believed.
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?JUDGE)
        (and
          (instance ?JUDGE MoralJudging)
          (agent ?JUDGE ?GROUP)
          (result ?JUDGE ?S)
          (refers ?S (ClassToSetFn ?B))
          (subclass ?B AutonomousAgentProcess)
          (believes ?GROUP
            (exists (?MEMB)
              (and
                (member ?MEMB ?GROUP)
                (capability ?B agent ?MEMB)))))))))

;; Decided that by their structure, the sentences do not necessarily refer to behavior.
;; The moral judgment process may, however!
(and
  (refers Ethics
    (and ?MT ?GROUP))
  (instance ?MT MoralTheory)
  (instance ?GROUP Group)
  (forall (?SENTENCE)
    (=>
      (element ?SENTENCE ?MT)
      (exists (?JUDGE)
        (and
          (instance ?JUDGE MoralJudging)
          (agent ?JUDGE ?GROUP)
          (result ?JUDGE ?SENTENCE)
          (refers ?JUDGE (ClassToSetFn ?BEHAVIOR))
          (subclass ?BEHAVIOR AutonomousAgentProcess)
          (believes ?GROUP
            (exists (?MEMB)
              (and
                (member ?MEMB ?GROUP)
                (capability ?BEHAVIOR agent ?MEMB)))))))))

(=> 
  (instance ?MP Ethics)
  (exists (?MT ?GROUP)
    (and 
      (instance ?MT MoralTheory)
      (instance ?GROUP Group)
      (refers ?MP (and ?MT ?GROUP))
      (forall (?SENTENCE)
        (=>
          (element ?SENTENCE ?MT)
          (exists (?JUDGE ?BEHAVIOR)
            (and
              (instance ?JUDGE MoralJudging)
              (agent ?JUDGE ?GROUP)
              (result ?JUDGE ?SENTENCE)
              (refers ?JUDGE (ClassToSetFn ?BEHAVIOR))
              (subclass ?BEHAVIOR AutonomousAgentProcess)
              (believes ?GROUP
                (exists (?MEMB)
                  (and
                    (member ?MEMB ?GROUP)
                    (capability ?BEHAVIOR agent ?MEMB)))))))))))

(documentation MoralNihilism EnglishLanguage "'Moral Nihilism is the view that nothing is morally wrong' (SEP - Moral Skepticism). 
Moral Nihilism can also be defined as 'the view that there are no moral facts' (Ethics: The Fundamentals).")
(subclass MoralNihilism Ethics)
 
(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?MORALSTATEMENT)
            (and
              (instance ?MORALSTATEMENT MoralSentence)
              (instance ?MORALSTATEMENT Fact))))))))

(=>
  (instance ?MN MoralNihilism)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?MN)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (not
          (exists (?BEHAVIORCLASS)
            (and
              (subclass ?BEHAVIORCLASS AutonomousAgentProcess)
              (modalAttribute
                (exists (?BEHAVIORINSTANCE)
                  (instance ?BEHAVIORINSTANCE ?BEHAVIORCLASS)) MorallyWrong))))))))

(documentation conformsFormula EnglishLanguage "(conforms ?OBJ ?FORMULA) describes how ?OBJ follows the ideas outlined by the proposition represented by ?FORMULA.")
(domain conformsFormula 1 Object)
(domain conformsFormula 2 Formula)
(instance conformsFormula BinaryPredicate)
(subrelation conformsFormula represents)

(<=>
  (conformsFormula ?OBJ ?FORMULA)
  (exists (?PROP)
    (and
      (containsInformation ?FORMULA ?PROP)
      (conforrms ?OBJ ?PROP))))
                       
(documentation realizesFormula EnglishLanguage "(conforms ?PROC ?FORMULA) describes how ?PROC follows the ideas outlined by the proposition represented by ?FORMULA.")
(domain realizesFormula 1 Process)
(domain realizesFormula 2 Formula)
(instance realizesFormula BinaryPredicate)
(subrelation realizesFormula represents)

;; A process conforms to a formula if and only if there exists a proposition such that:
;; a) the formula contains the information of the proposition.
;; b) the process is the realization of the proposition.
(<=>
  (realizesFormula ?PROCESS ?FORMULA)
  (exists (?PROP)
    (and
      (containsInformation ?FORMULA ?PROP)
      (realization ?PROCESS ?PROP))))

(documentation realizesFormulaSubclass EnglishLanguage "(conforms ?CPROC ?FORMULA) describes how ?CPROC follows the ideas outlined by the proposition represented by ?FORMULA.")
(domainSubclass realizesFormulaSubclass 1 Process)
(domain realizesFormulaSubclass 2 Formula)
(instance realizesFormulaSubclass BinaryPredicate)
(subrelation realizesFormulaSubclass represents)              
                                            
;; A subclass of Process conforms to a formula if there exists a proposition such that:
;; a) the formula contains the information of the proposition.
;; b) all instances of the subclass are realizations of the proposition.
(<=>
  (realizesFormulaSubclass ?CPROCESS ?FORMULA)
  (exists (?PROP)
    (and
      (containsInformation ?FORMULA ?PROP)
      (forall (?IPROCESS)
        (=>
          (instance ?IPROCESS ?CPROCESS)
          (realization ?IPROCESS ?PROP))))))

(documentation Deontology EnglishLanguage "Deontology is the ethical paradigm that judges 
the morality of an action based on the action's adherence to a set of rules and principles.")
(subclass Deontology Ethics)

;; Hmm, how to do this is tricky.  Why say that the process is something YOU do?  It's just good for there to be some process realizing obligations, right?
;; Also, I'm not sure how to mix in the deontological language.
;; The below will be very experimental!
(=>
  (instance ?D Deontology)
  (exists (?PROP ?STATE)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?STATE ?PROP)
      (similar ?STATE
        (exists (?RULE ?DEONTIC)
          (and
            (instance ?DEONTIC DeonticAttribute)
            (modalAttribute ?RULE ?DEONTIC)
            (=>
              (modalAttribute ?RULE Obligation)
              (modalAttribute
                (exists (?PROCESS)
                  (realizesFormula ?PROCESS ?RULE)) MorallyGood))))))))

;; All instances of deontology have subpropositions that contain moral sentences.
;; These moral sentences are elements of a deontological theory.
;; I think this is good to say.  Clearly I want a "this sentence is a deontological sentence" shorthand".
;;                
(=>
  (instance ?D Deontology)
  (exists (?PROP ?SENT)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?SENT ?PROP)
      (instance ?SENT MoralSentence)
      (exists (?THEORY)
        (and 
          (instance ?THEORY DeontologicalTheory)
          (element ?SENT ?THEORY))))))
          
(=>
  (instance ?MT DeontologicalTheory)
  (exists (?MP)
    (and
      (instance ?MP Deontology)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP))))))))

;; What about something whacky like this?
;; There exists a moral theory and a moral philosophy such that
;; every sentence of the moral theory is contained in the moral philosophy
;; and for every sentence, there is a corresponding rule?
(exists (?MT ?MP)
  (and
    (instance ?MP Deontology)
    (instance ?MT ValueJudgmentTheory)
    (forall (?S)
      (=>
        (element ?S ?MT)
        (and
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP)))
          (exists (?RULE ?DEONTIC)
            (and
              (instance ?DEONTIC DeonticAttribute)
              (modalAttribute ?RULE ?DEONTIC)
              (=>
                (equal ?DEONTIC Obligation)
                (equal ?S
                  (and
                    (modalAttribute
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE)) MorallyGood)
                    (modalAttribute
                      (not
                        (exists (?PROC)
                          (realizesFormula ?PROC ?RULE))) MorallyBad)))))))))))
            
;; This can be modularly simplified!
(exists (?MT)
  (and
    (instance ?MT ValueJudgmentTheory)
    (forall (?S)
      (=>
        (element ?S ?MT)
        (exists (?RULE ?DEONTIC)
          (and
            (instance ?DEONTIC DeonticAttribute)
            (modalAttribute ?RULE ?DEONTIC)
            (=>
              (equal ?DEONTIC Obligation)
              (equal ?S
                (and
                  (modalAttribute
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE)) MorallyGood)
                  (modalAttribute
                    (not
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE))) MorallyBad))))))))))      
     
;; Let's just say that the standard deontic operators cover all deontolgical theories.
;; Assuming rights-based approaches etc can be translated into this form ;- )
(=>
  (instance ?MT ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?RULE ?DEONTIC)
        (and
          (instance ?DEONTIC DeonticAttribute)
          (modalAttribute ?RULE ?DEONTIC)
          (=>
            (equal ?DEONTIC Obligation)
            (equal ?S
              (and
                (modalAttribute
                  (exists (?PROC)
                    (realizesFormula ?PROC ?RULE)) MorallyGood)
                (modalAttribute
                  (not
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE))) MorallyBad))))
          (=>
            (equal ?DEONTIC Prohibition)
            (equal ?S
              (modalAttribute
                (exists (?PROC)
                  (realizesFormula ?PROC ?RULE)) MorallyBad)))
          (=>
            (equal ?DEONTIC Permission)
            (equal ?S
              (forall (?CPROC)
                (=>
                  (realizesFormulaSubclass ?CPROC ?RULE)
                  (modalAttribute
                    (exists (?PREN)
                      (and
                        (instance ?PREN AutonomousAgentProcess)
                        (prevents ?PREN ?CPROC))) MorallyBad))))))))))

;; Let's see what it looks like if I place everything within the modalAttribute.
(=>
  (instance ?MT ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?RULE ?DEONTIC)
        (and
          (instance ?DEONTIC DeonticAttribute)
          (modalAttribute ?RULE ?DEONTIC)
          (=>
            (equal ?DEONTIC Obligation)
            (exists (?S2 ?G ?B)
              (and
                (element ?S2 ?MT)
                (equal ?G
                  (modalAttribute
                    (exists (?PROC)
                      (realizesFormula ?PROC ?RULE)) MorallyGood))
                (equal ?B
                  (modalAttribute
                    (not
                      (exists (?PROC)
                        (realizesFormula ?PROC ?RULE))) MorallyBad))
                (or 
                  (and (equal ?S ?G) (equal ?S2 ?B))
                  (and (equal ?S ?B) (equal ?S2 ?G))))))
          (=>
            (equal ?DEONTIC Prohibition)
            (equal ?S
              (modalAttribute
                (exists (?PROC)
                  (realizesFormula ?PROC ?RULE)) MorallyBad)))
          (=>
            (equal ?DEONTIC Permission)
            (exists (?S2 ?TEMP1 ?TEMP2)
              (and
                (element ?S2 ?MT)
                (equal ?TEMP1
                  (modalAttribute
                    (exists (?CPROC)
                      (realizesFormulaSubclass ?CPROC ?RULE)) MorallyNeutral))
                (equal ?TEMP2
                    (modalAttribute
                        (exists (?CPROC ?PREN)
                          (and
                            (realizesFormulaSubclass ?CPROC ?RULE)
                            (exists (?PREN)
                              (and
                                (instance ?PREN AutonomousAgentProcess)
                                (prevents ?PREN ?CPROC))))) MorallyBad))
                (or 
                  (and (equal ?S ?TEMP1) (equal ?S2 ?TEMP1))
                  (and (equal ?S ?TEMP2) (equal ?S2 ?TEMP2)))))))))))

;; I think to do this I need to define the structure of a SimpleValueJudgmentSentence as well as a ImperativeSentence.
;; Then I can say that for all parts either they are equal or they are an ImperativeSentence which is equivalent to the SimpleValueJudgmentSentence.
;; And I wish to say that the theories are equivalent but... in terms of what?
;; I'll also do the reverse mapping...?  Hmm.
;; Well, this is my OPPA Mapping Style!
;; Oh, I could actually just define the map, lol!

;; This function basically is what I've been calling "Deontology":
;; A mapping from imperative-type deontological sentences into value judgment-type deontological sentences
;; And then the mapping of Moral Judgments over the sentences as if to say, 
;; Society has considered these moral sentences and concluded them to be 'true' (or whatever else one does with them).
(documentation ImperativeToValueJudgmentSentenceFn EnglishLanguage "A UnaryFunction that maps simple imperative sentences into value judgment sentences.")
(domain ImperativeToValueJudgmentSentenceFn 1 SimpleImperativeSentence)
(range ImperativeToValueJudgmentSentenceFn ValueJudgmentSentence)
(instance ImperativeToValueJudgmentSentenceFn TotalValuedRelation)
(instance ImperativeToValueJudgmentSentenceFn UnaryFunction)

(=> 
  (and 
    (equal (ImperativeToValueJudgmentSentenceFn ?ITS) ?VJS)
    (equal ?ITS (modalAttribute ?RULE ?DEONTIC))
    (instance ?RULE Formula)
    (instance ?DEONTIC DeonticAttribute))
  (and
    (=>
      (equal ?DEONTIC Obligation)
      (equal ?VJS
        (and
          (modalAttribute
            (exists (?PROC)
              (realizesFormula ?PROC ?RULE)) MorallyGood)
          (modalAttribute
            (not
              (exists (?PROC)
                (realizesFormula ?PROC ?RULE))) MorallyBad))))
    (=>
      (equal ?DEONTIC Prohibition)
      (equal ?VJS
        (modalAttribute
          (exists (?PROC)
            (realizesFormula ?PROC ?RULE)) MorallyBad)))
    (=>
      (equal ?DEONTIC Permission)
      (equal ?VJS
        (forall (?CPROC)
          (=>
            (realizesFormulaSubclass ?CPROC ?RULE)
            (modalAttribute
              (exists (?PREN)
                (and
                  (instance ?PREN AutonomousAgentProcess)
                  (prevents ?PREN ?CPROC))) MorallyBad))))))) 

;; So now the 'too strong' claim above can be expressed very simply.
;; Now it's like, uhm, why even say this?
;; Because it's the kind of thing we'd probably like to be able to say.
(=>
  (instance ?MT ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?ITS)
        (and
          (instance ?ITS SimpleImperativeSentence)
          (equal ?S (ImperativeToValueJudgmentSentenceFn ?ITS)))))))  
;; (=> 
;;   (instance ?IT DeontologicalImperativeTheory)
;;   (exists (?DT)
;;     (and
;;       (instance ?DT DeontologicalValueJudgmentTheory)
;;       (forall (?S1)
;;         (=> 
;;           (element ?S1 ?IT)
;;           (and
;;             (=> 
;;               (not (instance ?S1 ?SimpleImperativeSentence))))))))

;; Let's do the inverse!
;; In this case it is simple -> simpl:
(documentation ValueJudgmentToImperativeSentenceFn EnglishLanguage "A UnaryFunction that maps simple value judgment sentences into imperative sentences.")
(domain ValueJudgmentToImperativeSentenceFn 1 SimpleValueJudgmentSentence)
(range ValueJudgmentToImperativeSentenceFn SimpleImperativeSentence)
(instance ValueJudgmentToImperativeSentenceFn TotalValuedRelation)
(instance ValueJudgmentToImperativeSentenceFn UnaryFunction)

;; This might be too simple and strong?  
;; There is the issue of the strength of an obligation etc, right?
;; One cannot go from imperatives to value judgments and back to imperatives.
;; A quite quirk is that going from a value judgment to an imperative and back says that:
;; It is MorallyBad to prevent someone from doing something that is MorallyNeutral?
(=> 
  (and 
    (equal (ValueJudgmentToImperativeSentenceFn ?VJS) ?ITS)
    (equal ?VJS (modalAttribute ?SITUATION ?MORALATTRIBUTE))
    (instance ?SITUATION Formula)
    (instance ?MORALATTRIBUTE MoralAttribute))
  (and
    (=>
      (equal ?MORALATTRIBUTE MorallyGood)
      (equal ?ITS 
        (modalAttribute ?SITUATION Obligation)))
    (=>
      (equal ?MORALATTRIBUTE MorallyBad)
      (equal ?ITS
        (modalAttribute ?SITUATION Prohibition)))
    (=>
      (equal ?MORALATTRIBUTE MorallyNeutral)
      (equal ?ITS
        (modalAttribute ?SITUATION Permission)))))

;; Might as well see how this looks and feels.
(documentation GenericImperativeToValueJudgmentSentenceFn EnglishLanguage "A UnaryFunction that maps simple imperative sentences into value judgment sentences in a very generic manner.")
(domain GenericImperativeToValueJudgmentSentenceFn 1 SimpleImperativeSentence)
(range GenericImperativeToValueJudgmentSentenceFn ValueJudgmentSentence)
(instance GenericImperativeToValueJudgmentSentenceFn TotalValuedRelation)
(instance GenericImperativeToValueJudgmentSentenceFn UnaryFunction)

;; So letting the Rule be fully general, such as 
;; (modalAttribute
;;   (exists (?PET)
;;     (and
;;         (instance ?PET DomesticAnimal)
;;         (located ?PET ?LOC))) Prohibition)
;; If this is prohibited, then it's morally bad for the pet to be located there.
;; Do we wish to say that it's morally bad to instantiate a process that realizes the pet being there?
;; Yeah, kind of, to be honest.
;; Yet it's also good to just say that it's bad, lol.
;; Maybe I like the generic versions.
;; And wish to do the realizing and the causal realization claims separately?
(=> 
  (and 
    (equal (GenericImperativeToValueJudgmentSentenceFn ?ITS) ?VJS)
    (equal ?ITS (modalAttribute ?RULE ?DEONTIC))
    (instance ?RULE Formula)
    (instance ?DEONTIC DeonticAttribute))
  (and
    (=>
      (equal ?DEONTIC Obligation)
      (equal ?VJS
        (and
          (modalAttribute ?RULE MorallyGood)
          (modalAttribute (not ?RULE) MorallyBad))))
    (=>
      (equal ?DEONTIC Prohibition)
      (equal ?VJS
        (modalAttribute ?RULE MorallyBad)))
    (=>
      (equal ?DEONTIC Permission)
      (equal ?VJS 
        (modalAttribute ?RULE MorallyNeutral)))))

;; This demonstrates that the 'second' rule of the obligation translation is not needed
;; For it is implied by the first in an Imperative Theory.
(=>
  (and
    (=>
      (modalAttribute ?FORMULA Obligation)
      (not
        (modalAttribute
          (not ?FORMULA) Permission)))
    (=>
      (not
        (modalAttribute
          (not ?FORMULA) Permission))
      (modalAttribute
        (not ?FORMULA) Prohibition)))
  (modalAttribute
    (not ?FORMULA) Prohibition))

;; For this rule, we only need to deal with the permissive case because Obligation ?F => Permission ?F. 
;; Thus this is not part of the translation between the imperative and value judgment languages.
;; It's actually a lemma of a moral theory ;- ).
;; One might claim that a prohibition on NOT ?FORMULA implies that preventing ?FORMULA is bad...,
;; Which probably does follow . . ..
;; I wonder if one needs to add agents in here, i.e., is choosing not to do something preventing myself?  Not quite...?
(forall (?RULE ?CPROC)
  (=>
    (and
      (realizesFormulaSubclass ?CPROC ?RULE)
      (modalAttribute ?RULE Permission))
    (modalAttribute
      (exists (?PREV)
        (and
          (instance ?PREV AutonomousAgentProcess)
          (prevents ?PREV ?CPROC))) Prohibition)))
    

;; Maybe it should be simplified to the following:
(=> 
  (and 
    (equal (GenericImperativeToValueJudgmentSentenceFn ?ITS) ?VJS)
    (equal ?ITS (modalAttribute ?RULE ?DEONTIC))
    (instance ?RULE Formula)
    (instance ?DEONTIC DeonticAttribute))
  (and
    (=>
      (equal ?DEONTIC Obligation)
      (equal ?VJS
        (modalAttribute ?RULE MorallyGood)))
    (=>
      (equal ?DEONTIC Prohibition)
      (equal ?VJS
        (modalAttribute ?RULE MorallyBad)))
    (=>
      (equal ?DEONTIC Permission)
      (equal ?VJS 
        (modalAttribute ?RULE MorallyNeutral)))))
        
;; This is also obviously too strong, I guess.
(=>
  (instance ?MT DeontologicalImperativeTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (exists (?VJS)
        (and
          (instance ?VJS SimpleValueJudgmentSentence)
          (equal ?S (ValueJudgmentToImperativeSentenceFn ?VJS)))))))

;; What about this?
;; For every imperative deontological theory,
;; For every part of a sentence that is a simple imperative sentence,
;; There exists some value judgment sentence that gets mapped to it.
(=>
  (instance ?MT DeontologicalImperativeTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (forall (?P)
        (=> 
          (and 
            (part ?P ?S)
            (instance ?P SimpleImperativeSentence))
          (exists (?VJS)
            (and
              (instance ?VJS SimpleValueJudgmentSentence)
              (equal ?P (ValueJudgmentToImperativeSentenceFn ?VJS)))))))))

;; For every deontological value judgment theory, 
;; For every part of each sentence that is a simple value judgment,
;; There exists some imperative statement of which this is a part.
;; Basically I'm constraining the form of the Formulas in the value judgments to be:
;; (a) realizing X is good
;; (b) realizing X is bad
;; (c) not realizing X is bad
;; (d) preventing Y from realizing X is bad.
;; Maybe I should just say this explicitly, lol.
;; And it clearly misses stuff like, "If X is bad to do, then preventing Y from realizing X is good."
;; But you can fit that into (A) by substituting "prevetning Y yfrom doing X" into X.
;; So, technically, this is going to be contradicted by the general rule for value judgment statements.
;; Mmm, no, I think the simple version works for this, actually.
(=>
  (instance ?MT ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (forall (?P)
        (=> 
          (and
            (part ?P ?S)
            (instance ?P SimpleValueJudgmentSentence))
          (exists (?ITS)
            (and
              (instance ?ITS SimpleImperativeSentence)
              (part ?P (ImperativeToValueJudgmentSentenceFn ?ITS)))))))))

;; Anyway, this can be corrected into a clean version.
(=>
  (instance ?MT ValueJudgmentTheory)
  (forall (?S)
    (=>
      (element ?S ?MT)
      (forall (?P)
        (=> 
          (and
            (part ?P ?S)
            (instance ?P SimpleValueJudgmentSentence))
          (exists (?ITS)
            (and
              (instance ?ITS SimpleImperativeSentence)
              (equal ?P (GenericImperativeToValueJudgmentSentenceFn ?ITS)))))))))

;; What I want to do really should just be done with proper structural recursion in terms of subFormula with pattern match...
;; (=>
;;   (instance ?VJT ValueJudgmentTheory)
;;   (exists (?IT)
;;     (forall (?VJS)
;;       (=>
;;         (element ?S ?MT)
;;         (forall (?PJS)
;;           (=>
;;             (part ?PJS ?VJS)
;;             (or
;;               (=>
;;                 (instance ?P SimpleImperativeSentence)
;;                 ())
;;               )))))))

(=>
  (instance ?S SimpleValueJudgmentSentence)
  (equal ?S
    (GenericImperativeToValueJudgmentSentenceFn
      (ValueJudgmentToImperativeSentenceFn ?S))))

(=>
  (instance ?S SimpleImperativeSentence)
  (equal ?S
    (ValueJudgmentToImperativeSentenceFn
      (GenericImperativeToValueJudgmentSentenceFn ?S))))

(documentation VirtueEthics EnglishLanguage "Virtue ethics is the ethical paradigm that judges the morality of an action 
based on the character of the agent performing an action.  A virtuous agent is one who possesses virtues.  
'An action is right if and only if it is what a virtuous agent would characteristically (i.e., acting in character) 
do in the circumstances' (On Virtue Ethics -- Right Action).")
(subclass VirtueEthics Ethics)

;; Linking Virtue Ethics with its Theories. V1
(=>
  (instance ?D VirtueEthics)
  (exists (?PROP ?SENT)
    (and
      (subProposition ?PROP ?D)
      (containsInformation ?SENT ?PROP)
      (instance ?SENT MoralSentence)
      (exists (?THEORY)
        (and
          (instance ?THEORY VirtueEthicsTheory)
          (element ?SENT ?THEORY))))))
          
;; For all instances of virtue ethics, there exists a virtue ethics theory
;; Such that all of its sentences are propositions of the virtue ethics instance.
;; Basically, the whole "moral sentence" thing is extraneous now :- ).
;; I feel as if we'd need greater precision to make the implication go both ways.  
;; We'd need to get more logical-implication level.
;; Yeah, I'm not sure how to avoid the trivialization without quantifying over subPropositionos, which is tricky as P is a subProposition of ~P.
(=>
  (instance ?MP VirtueEthics)
  (exists (?MT)
    (and
      (instance ?MT VirtueEthicsTheory)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP))))))))

;; So this is probably the best I can easily do.  
;; I see no reason why any 'theory' as a set of sentences can't be represented as a sentence of potentially infinite length by 'anding' each sentence together into one.
(=> 
  (instance ?MP VirtueEthics)
  (exists (?MTS)
    (and 
      (containsInformation ?MTS ?MP)
      (instance ?MTS VirtueEthicsSentence))))

;; Weirdly, quantifying over subPropositions seems too vague.
;; So we go over sentences in both directions.
(=>
  (instance ?MT VirtueEthicsTheory)
  (exists (?MP)
    (and
      (instance ?MP VirtueEthics)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?PROP)
            (and
              (containsInformation ?S ?PROP)
              (subProposition ?PROP ?MP))))))))

;; Sure, let's add these!         
(=> 
  (instance ?MP VirtueEthics)
  (exists (?MT ?MTS)
    (and
      (instace ?MT VirtueEthicsTheory)
      (containsInformation ?MTS ?MP)
      (instance ?MTS VirtueEthicsSentence)
      (equal ?MTS (ListAndFn (SetToListFn ?MT))))))
      
(=> 
  (instance ?MP VirtueEthics)
  (exists (?MT ?MTS)
    (and
      (instace ?MT VirtueEthicsTheory)
      (containsInformation ?MTS ?MP)
      (instance ?MTS VirtueEthicsSentence)
      (equal ?MTS (ListAndFn (SetToListFn ?MT)))
      (forall (?S)
        (=> 
          (element ?S ?MT)
          (exists (?P)
            (and
              (containsInformation ?S ?P)
              (subProposition ?P ?MP))))))))

;; So let's define a map from simple virtue ethics statements to value judgment statements.
(documentation SimpleVirtueToValueJudgmentSentenceFn EnglishLanguage "A UnaryFunction that maps simple virtue ethics sentences into value judgment sentences.")
(domain SimpleVirtueToValueJudgmentSentenceFn 1 SimpleVirtueEthicsSentence)
(range SimpleVirtueToValueJudgmentSentenceFn ValueJudgmentSentence)
(instance SimpleVirtueToValueJudgmentSentenceFn TotalValuedRelation)
(instance SimpleVirtueToValueJudgmentSentenceFn UnaryFunction)

;; I see how the target-centric virtue ethics is important here.
;; If one is ascribed the virtue of honesty, then when a decision involves the scope of honesty,
;; one's behavior resulting from the decision is likely to be morally good.
;; This doesn't extend beyond the relevant scope, however!
(=>
  (and
    (equal
      (SimpleVirtueToValueJudgmentSentenceFn ?SVS) ?VJS)
    (equal ?SVS
      (attribute ?AGENT ?VIRTUEATTRIBUTE))
    (instance ?AGENT AutonomousAgent))
  (and
    (=>
      (instance ?VIRTUEATTRIBUTE VirtueAttribute)
      (equal ?VJS
        (forall (?DECIDE ?DECISION)
          (=>
            (and
              (instance ?DECIDE Deciding)
              (agent ?DECIDE ?AGENT)
              (refers ?VIRTUEATTRIBUTE ?DECIDE)
              (result ?DECIDE
                (ClassToSetFn ?DECISION)))
            (modalAttribute
              (modalAttribute
                (exists (?INSTANCE)
                  (and
                    (agent ?INSTANCE ?AGENT)
                    (instance ?INSTANCE ?DECISION))) MorallyGood) Likely)))))
    (=>
      (instance ?VIRTUEATTRIBUTE ViceAttribute)
      (equal ?VJS
        (forall (?DECIDE ?DECISION)
          (=>
            (and
              (instance ?DECIDE Deciding)
              (agent ?DECIDE ?AGENT)
              (refers ?VIRTUEATTRIBUTE ?DECIDE)
              (result ?DECIDE
                (ClassToSetFn ?DECISION)))
            (modalAttribute
              (modalAttribute
                (exists (?INSTANCE)
                  (and
                    (agent ?INSTANCE ?AGENT)
                    (instance ?INSTANCE ?DECISION))) MorallyBad) Likely)))))))

;; Let's try to remove the decision middle-man.
;; This time, if a virtuous entity is known to have taken some behavior, then it's probably a good thing to do in general.
(=>
  (and
    (equal (SimpleVirtueToValueJudgmentSentenceFn ?SVS) ?VJS)
    (equal ?SVS (attribute ?AGENT ?VIRTUEATTRIBUTE))
    (instance ?AGENT AutonomousAgent))
  (and 
    (=> 
      (instance ?VIRTUEATTRIBUTE VirtueAttribute) 
      (equal ?VJS 
        (forall (?PROC)
          (=> 
            (and
              (subclass ?PROC AutonomousAgentProcess)
              (refers ?VIRTUEATTRIBUTE (ClassToSetFn ?PROC))
              (exists (?INSTANCE)
                (and 
                  (agent ?INSTANCE ?AGENT)
                  (instance ?INSTANCE ?PROC))))
            (modalAttribute 
              (modalAttribute 
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyGood) Likely)))))
    (=>
      (instance ?VIRTUEATTRIBUTE ViceAttribute) 
      (equal ?VJS 
        (forall (?PROC)
          (=> 
            (and
              (subclass ?PROC AutonomousAgentProcess)
              (refers ?VIRTUEATTRIBUTE (ClassToSetFn ?PROC))
              (exists (?INSTANCE)
                (and
                  (agent ?INSTANCE ?AGENT)
                  (instance ?INSTANCE ?PROC))))
            (modalAttribute 
              (modalAttribute 
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyBad) Likely)))))))

;; Maybe let's say that if it's likely for the virtuous agent to do X, then it's likely good to do X in general.
(=>
  (and
    (equal (SimpleVirtueToValueJudgmentSentenceFn ?SVS) ?VJS)
    (equal ?SVS (attribute ?AGENT ?VIRTUEATTRIBUTE))
    (instance ?AGENT AutonomousAgent))
  (and 
    (=> 
      (instance ?VIRTUEATTRIBUTE VirtueAttribute) 
      (equal ?VJS 
        (forall (?PROC)
          (=> 
            (and
              (subclass ?PROC AutonomousAgentProcess)
              (refers ?VIRTUEATTRIBUTE (ClassToSetFn ?PROC))
              (modalAttribute
                (exists (?INSTANCE)
                  (and 
                    (agent ?INSTANCE ?AGENT)
                    (instance ?INSTANCE ?PROC))) Likely))
            (modalAttribute 
              (modalAttribute 
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyGood) Likely)))))
    (=>
      (instance ?VIRTUEATTRIBUTE ViceAttribute) 
      (equal ?VJS 
        (forall (?PROC)
          (=> 
            (and
              (subclass ?PROC AutonomousAgentProcess)
              (refers ?VIRTUEATTRIBUTE (ClassToSetFn ?PROC))
              (modalAttribute
                (exists (?INSTANCE)
                  (and 
                    (agent ?INSTANCE ?AGENT)
                    (instance ?INSTANCE ?PROC))) Likely))
            (modalAttribute 
              (modalAttribute 
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyBad) Likely)))))))

;; We can generalize this beyond the 'agent' role!
;; We'll get a rule that probably too associatively considers an process a virtuous agent is a part of as 'good'.
(=>
  (and
    (equal
      (SimpleVirtueToValueJudgmentSentenceFn ?SVS) ?VJS)
    (equal ?SVS
      (attribute ?AGENT ?VIRTUEATTRIBUTE))
    (instance ?AGENT AutonomousAgent))
  (and
    (=>
      (instance ?VIRTUEATTRIBUTE VirtueAttribute)
      (equal ?VJS
        (forall (?PROC ?ROLE ?TIME ?PLACE)
          (=>
            (and
              (subclass ?PROC Process)
              (playsRoleInEventOfType ?AGENT ?ROLE ?PROC ?TIME ?PLACE)
              (refers ?VIRTUEATTRIBUTE ?PROC))
            (modalAttribute
              (modalAttribute
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyGood) Likely)))))
    (=>
      (instance ?VIRTUEATTRIBUTE ViceAttribute)
      (equal ?VJS
        (forall (?PROC)
          (=>
            (and
              (subclass ?PROC Process)
              (playsRoleInEventOfType ?AGENT ?ROLE ?PROC ?TIME ?PLACE)
              (refers ?VIRTUEATTRIBUTE ?PROC))
            (modalAttribute
              (modalAttribute
                (exists (?INSTANCE)
                  (instance ?INSTANCE ?PROC)) MorallyBad) Likely)))))))

;; Copied from Draft 3 for now . . . 
(documentation Change EnglishLanguage "Processes that involve altering a property of an Entity.")
(subclass Change Process)
(subclass InternalChange Change)

(=>
  (and
    (instance ?CHANGE Change)
    (patient ?CHANGE ?ENTITY))
  (exists (?PROPERTY)
    (or
      (and
        (holdsDuring
          (BeginFn
            (WhenFn ?CHANGE))
          (property ?ENTITY ?PROPERTY))
        (holdsDuring
          (EndFn
            (WhenFn ?CHANGE))
          (not
            (property ?ENTITY ?PROPERTY))))
      (and
        (holdsDuring
          (BeginFn
            (WhenFn ?CHANGE))
          (not
            (property ?ENTITY ?PROPERTY)))
        (holdsDuring
          (EndFn
            (WhenFn ?CHANGE))
          (property ?ENTITY ?PROPERTY))))))

;; Likewise, copied . . .
(documentation influences EnglishLanguage "The influence relation between instances of Entities (influences ?ENTITY1 ?ENTITY2 denotes that ?ENTITY has some effect on ?ENTITY2")
(domain influences 1 Entity)
(domain influences 2 Entity)
(instance influences BinaryPredicate)
(relatedInternalConcept influences causes)

(=>
  (causes ?P1 ?P2)
  (influences ?P1 ?P2))

(=>
  (influences ?E1 ?E2)
  (exists (?CHANGE ?PROCESS)
    (and
      (instance ?CHANGE Change)
      (patient ?CHANGE ?E2)
      (causes ?PROCESS ?CHANGE)
      (involvedInEvent ?PROCESS ?E1))))

;; If something is good, then a virtuous person is likely to do it in the appropriate situation.
(documentation SimpleValueJudgmentToVirtueSentenceFn EnglishLanguage "A UnaryFunction that maps simple value judgment sentences into simple virtue ethics sentences.")
(domain SimpleValueJudgmentToVirtueSentenceFn 1 SimpleValueJudgmentSentence)
(range SimpleValueJudgmentToVirtueSentenceFn VirtueEthicsSentence)
(instance SimpleValueJudgmentToVirtueSentenceFn TotalValuedRelation)
(instance SimpleValueJudgmentToVirtueSentenceFn UnaryFunction)

;; Maybe I need some sort of "Lemma": 
;; if a formula is good and there's some process that realizes the formula, then this process is good.
;; This is basically what I had in the old 'translation'..., and now that it's been simplified, 
;; it's an additional lemma!
;; Also, note, if the process is an autonomous agent process, the existence of an agent is provided by a lemma already in SUMO.
(=>
  (and
    (instance ?SVJ SimpleValueJudgmentSentence)
    (equal ?SVJ (modalAttribute ?SITUATION ?MORALATTRIBUTE))
    (realizesFormulaSubclass ?PROC ?SITUATION))
  (modalAttribute
    (exists (?INSTANCE)
      (instance ?INSTANCE ?PROC)) ?MORALATTRIBUTE))

;; Causing a non-process situation seems not so well dealt-with,
;; But we can suggest it by saying that if some agent-process causes the realization of a situation,
;; Then it's good/bad for it to exist if the situation is good/bad.
;; Adding in likely because the behavior could have additional consequences.
(=>
  (and 
    (instance ?SVJ SimpleValueJudgmentSentence)
    (equal ?SVJ (modalAttribute ?SITUATION ?MORALATTRIBUTE))
    (realizesFormulaSubclass ?PROC ?SITUATION)
    (causesSubclass ?CAUSE ?PROC)
    (subclass ?CAUSE AutonomousAgentProcess))
  (modalAttribute
    (modalAttribute
      (exists (?INSTANCE)
        (instance ?INSTANCE ?CAUSE)) ?MORALATTRIBUTE) Likely)) 

;; Maybe just use causesProposition?
(=>
  (and 
    (instance ?SVJ SimpleValueJudgmentSentence)
    (equal ?SVJ (modalAttribute ?SITUATION ?MORALATTRIBUTE))
    (causesProposition ?CAUSE ?SITUATION)
    (realizesFormulaSubclass ?CAUSALPROCESS ?CAUSE)
    (subclass ?CAUSALPROCESS AutonomousAgentProcess))
  (modalAttribute
    (modalAttribute
      (exists (?INSTANCE)
        (instance ?INSTANCE ?CAUSALPROCESS)) ?MORALATTRIBUTE) Likely)) 

;; Probably I just need this Lemma to rule out perverse situations such as, "it's good for 1+1=2".
;; For every moral value judgment, there exists a behavior such that either,
;; 1) the situation refers to the behavior
;; 2) the situation refers to a process influenced by the behavior.
;; Can I make this a generic physical entity?  Or, meh, 
;; Maybe I should just make a predicate to denote the class of processes referred to by a situation?
;; It's confusing af.  The ontology here makes this sort of thing really hard to specify... 🤔
(=>
  (and 
    (instance ?SVJ SimpleValueJudgmentSentence)
    (equal ?SVJ (modalAttribute ?SITUATION ?MORALATTRIBUTE))
    (instance ?SITUATION Formula)
    (instance ?MORALATTRIBUTE MoralVirtueAttribute))
  (exists (?PROC)
    (and 
      (subclass ?PROC AutonomousAgentProcess)
      (or
        (refers ?SITUATION (ClassToSetFn ?PROC))
        (exists (?PROC2)
          (and
            (refers ?SITUATION (ClassToSetFn ?PROC2))
            (subclass ?PROC2 Process)
            (influencs ?PROC ?PROC2)))))))

;; Maybe let's make a version that goes through Deciding and one version that doesn't!
;; Just use refers... excessively... because the goal isn't exactly to fill in all the details.
;; Use 'influnces'?  Ugh, this is hard!
;; (=>
;;   (and
;;     (equal (SimpleValueJudgmentToVirtueSentenceFn ?SVJ) ?VES)
;;     (equal ?SVJ (modalAttribute ?SITUATION ?MORALATTRIBUTE)
;;     (instance ?SITUATION Formula)
;;     (instance ?MORALATTRIBUTE MoralAttribute)
;;     (refers ?SITUATION ?PROC)
;;     (subclass ?PROC AutonomousAgentProcess)))
;;   (and  
;;     (=>
;;       (equal ?MORALATTRIBUTE MorallyGood))
;;     (=>
;;       (equal ?MORALATTRIBUTE MorallyBad))))

(documentation SimpleActionValueJudgmentToVirtueSentenceFn EnglishLanguage "A UnaryFunction that maps simple action value judgment sentences into simple virtue ethics sentences.")
(domain SimpleActionValueJudgmentToVirtueSentenceFn 1 SimpleActionValueJudgmentSentence)
(range SimpleActionValueJudgmentToVirtueSentenceFn VirtueEthicsSentence)
(instance SimpleActionValueJudgmentToVirtueSentenceFn TotalValuedRelation)
(instance SimpleActionValueJudgmentToVirtueSentenceFn UnaryFunction)

;; So, leaving off anything about situations,
;; If an action is good/right and an agent possesses a virtue referring to this class of actions,
;; then it's likely the agent will take the action.
(=>
  (and 
    (equal (SimpleActionValueJudgmentToVirtueSentenceFn ?SAVJ) ?VES)
    (subclass ?CLASS AutonomousAgentProcess)
    (equal ?SAVJ (modalAttribute 
      (exists (?PROC)
        (instance ?PROC ?CLASS)) ?MORALATTRIBUTE)))
  (and
    (=>
      (equal ?MORALATTRIBUTE MorallyGood)
      (equal ?VES
        (forall (?AGENT)
          (=> 
            (and
              (instance ?AGENT VirtuousAgent)
              (exists (?VIRTUE)
                (and
                  (instance ?VIRTUE VirtueAttribute)
                  (attribute ?AGENT ?VIRTUE)
                  (refers ?VIRTUE (ClassToSetFn ?CLASS)))))
            (modalAttribute 
              (exists (?PROC)
                (and
                  (instance ?PROC ?CLASS)
                  (agent ?PROC ?AGENT))) Likely)))))
    (=>
      (equal ?MORALATTRIBUTE MorallyBad)
      (equal ?VES
        (forall (?AGENT)
          (=> 
            (and
              (instance ?AGENT ViciousAgent)
              (exists (?VICE)
                (and 
                  (instance ?VICE ViceAtribute)
                  (attribute ?AGENT ?VICE)
                   (refers ?VIRTUE (ClassToSetFn ?CLASS)))))
            (modalAttribute 
              (exists (?PROC)
                (and
                  (instance ?PROC ?CLASS)
                  (agent ?PROC ?AGENT))) Likely)))))))

;; Ok, another stab at a more general variety:
;; Oh, maybe I could say that if ?S is morally good, then if an agent takes an action that makes ?S more likely, 
;; then ?S is likely virtuous in all virtues relevant to ?S!!!  Ahahaha, what a good idea!  
;; IncreasesLikeliHood and causesProposition both... exist ;- D.

(=>
  (and
    (equal
      (SimpleValueJudgmentToVirtueSentenceFn ?SAVJ) ?VES)
    (equal ?SAVJ
      (modalAttribute ?FORMULA ?MORALATTRIBUTE)))
  (equal ?VES
    (forall (?AGENT ?PROC)
      (=>
        (and
          (instance ?AGENT AutonomousAgent)
          (subclass ?PROC AutonomousAgentProcess)
          (exists (?INSTANCE)
            (causesProposition
              (and
                (agent ?INSTANCE ?AGENT)
                (instance ?INSTANCE ?PROC)) ?FORMULA)))
        (forall (?VIRTUE)
          (=>
            (and
              (or
                (and 
                  (equal ?MORALATTRIBUTE MorallyGood)
                  (instance ?VIRTUE VirtueAttribute))
                (and
                  (equal ?MORALATTRIBUTE MorallyBad)
                  (instance ?VIRTUE ViceAttribute)))
              (refers ?VIRTUE ?FORMULA))
            (modalAttribute
              (attribute ?AGENT ?VIRTUE) Likely)))))))

(=>
  (and
    (equal
      (SimpleValueJudgmentToVirtueSentenceFn ?SAVJ) ?VES)
    (equal ?SAVJ
      (modalAttribute ?FORMULA ?MORALATTRIBUTE))
    (=> 
      (equal ?MORALATTRIBUTE MorallyGood)
      (subclass ?VIRTUETYPE VirtueAttribute))
    (=> 
      (equal ?MORALATTRIBUTE MorallyGood)
      (subclass ?VIRTUETYPE VirtueAttribute)))
  (equal ?VES
    (forall (?AGENT ?PROC)
      (=>
        (and
          (instance ?AGENT AutonomousAgent)
          (subclass ?PROC AutonomousAgentProcess)
          (exists (?INSTANCE)
            (increasesLikelihood
              (and
                (agent ?INSTANCE ?AGENT)
                (instance ?INSTANCE ?PROC)) ?FORMULA)))
        (forall (?VIRTUE)
          (=>
            (and
              (instance ?VIRTUE ?VIRTUETYPE)
              (refers ?VIRTUE ?FORMULA))
            (modalAttribute
              (attribute ?AGENT ?VIRTUE) Likely)))))))

; (=>
;   (instance ?MT VirtueEthicsTheory)
;   (forall (?S)
;     (=>
;       (element ?S ?MT)  )))                              


(documentation Utilitarianism EnglishLanguage "Utilitarianism is the ethical paradigm that judges the morality of an action 
based on whether it maximizes the good over the bad, which is typically determined via a utility function.")
(subclass Utilitarianism Ethics)

;; MP for Moral Philosophy or Moral Predicate
(=>
  (instance ?MP Utilitarianism)
  (exists (?MTS)
    (and 
      (containsInformation ?MTS ?MP)
      (instance ?MTS UtilitarianSentence))))

(=>
  (instance ?MP Utilitarianism)
  (exists (?MT)
    (and
      (instance ?MT UtilitarianTheory)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?P)
            (and
              (containsInformation ?S ?P)
              (subProposition ?P ?MP))))))))

;; So for a Utilitarian Proposition, there is some sentence that contains its information.
;; And there is a Utilitarian theory such that each sentence is a sub-string of this mega-sentence
;; And each sentence also corresponds to a su-proposition of the utilitarian proposition.
(=>
  (instance ?MP Utilitarianism)
  (exists (?MT ?MTS)
    (and
      (containsInformation ?MTS ?MP)
      (instance ?MTS UtilitarianSentence)
      (instance ?MT UtilitarianTheory)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (and
              (subString ?S ?MTS)
              (exists (?P)
                (and
                  (containsInformation ?S ?P)
                  (subProposition ?P ?MP)))))))))

;; Now that we can take the concatenation of a theory of sentences,
;; We can say that for a moral philosophy, 
;; there exists a moral theory whose 'and'-sentence contains the information of the philosophy.
(=>
  (instance ?MP Utilitarianism)
  (exists (?MT ?MTS)
    (and
      (instance ?MT UtilitarianTheory)
      (equal ?MTS (ListAndFn (SetToListFn ?MT)))
      (containsInformation ?MTS ?MP))))

;; And it might be nice to add that each sentence corresponds to a particular sub-proposition.  Y not?
(=>
  (instance ?MP Utilitarianism)
  (exists (?MT ?MTS)
    (and
      (instance ?MT UtilitarianTheory)
      (equal ?MTS (ListAndFn (SetToListFn ?MT)))
      (containsInformation ?MTS ?MP)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?P)
            (and
              (containsInformation ?S ?P)
              (subProposition ?P ?MP))))))))

;; The latter part is perhaps extraneous now, actually!  
(=>
  (instance ?MT UtilitarianTheory)
  (exists (?MP)
    (and 
      (instance ?MP Utilitarianism)
      (containsInformation (ListAndFn (SetToListFn ?MT)) ?MP)
      (forall (?S)
        (=>
          (element ?S ?MT)
          (exists (?P)
            (and
              (containsInformation ?S ?P)
              (subProposition ?P ?MP))))))))
              
(=>
  (instance ?MT UtilitarianTheory)
  (exists (?MP)
    (and 
      (instance ?MP Utilitarianism)
      (containsInformation (ListAndFn (SetToListFn ?MT)) ?MP))))

(documentation UtilityAssignmentToValueJudgmentSentenceFn EnglishLanguage "A UnaryFunction that maps utility assignment sentences into simple value judgment sentences.")
(domain UtilityAssignmentToValueJudgmentSentenceFn 1 UtilityAssignmentSentence)
(range UtilityAssignmentToValueJudgmentSentenceFn SimpleValueJudgmentSentence)
(instance UtilityAssignmentToValueJudgmentSentenceFn TotalValuedRelation)
(instance UtilityAssignmentToValueJudgmentSentenceFn UnaryFunction)

;; So if the utility is positive, it's good; negative, it's bad; and if it's zero, then it's neutral.
;; Super clean and simple!
(=> 
  (and 
    (equal (UtilityAssignmentToValueJudgmentSentenceFn ?UAS) ?VJS)
    (equal ?UAS (equal (AssignmentFn ?UF ?FORMULA) ?VALUE))
    (instance ?UF UtilityFormulaFn)
    (instance ?FORMULA Formula)
    (instance ?VALUE Number))
  (and
    (=>
      (greaterThan ?VALUE 0)
      (equal ?VJS
        (modalAttribute ?FORMULA MorallyGood)))
    (=>
      (lessThan ?VALUE 0)
      (equal ?VJS
        (modalAttribute ?FORMULA MorallyBad)))
    (=>
      (equal ?VALUE 0)
      (equal ?VJS 
        (modalAttribute ?FORMULA MorallyNeutral)))))
        
;; As a demonstration of arbitrariness.
(=>
  (and
    (equal
      (UtilityAssignmentToValueJudgmentSentenceFn ?UAS) ?VJS)
    (equal ?UAS
      (equal
        (AssignmentFn ?UF ?FORMULA) ?VALUE))
    (instance ?UF UtilityFormulaFn)
    (instance ?FORMULA Formula)
    (instance ?VALUE Number))
  (and
    (=>
      (greaterThanOrEqualTo ?VALUE 10)
      (equal ?VJS
        (modalAttribute ?FORMULA MorallyGood)))
    (=>
      (lessThanOrEqualTo ?VALUE -10)
      (equal ?VJS
        (modalAttribute ?FORMULA MorallyBad)))
    (=>
      (and
        (lessThan ?VALUE 10)
        (greaterThan ?VALUE -10))
      (equal ?VJS
        (modalAttribute ?FORMULA MorallyNeutral)))))

(documentation ValueJudgmentToUtilityAssignmentSentenceFn EnglishLanguage "A UnaryFunction that maps value judgment sentences to utility assignment sentences.")
(domain ValueJudgmentToUtilityAssignmentSentenceFn 1 SimpleValueJudgmentSentence)
(range ValueJudgmentToUtilityAssignmentSentenceFn UtilityAssignmentSentence)
(instance ValueJudgmentToUtilityAssignmentSentenceFn TotalValuedRelation)
(instance ValueJudgmentToUtilityAssignmentSentenceFn UnaryFunction)

;; So this is also trivial.  We just need to assign 1 to good, -1 to bad, and 0 to neutral.
;; If there's a notion of the strengths of moral value judgments, this ports over cleanly.
(=> 
  (and 
    (equal (ValueJudgmentToUtilityAssignmentSentenceFn ?VJS) ?UAS)
    (equal ?VJS (modalAttribute ?FORMULA ?MORALATTRIBUTE))
    (instance ?FORMULA Formula)
    (instance ?MORALATTRIBUTE MoralAttribute)
    (instance ?UF UtilityFormulaFn))
  (and
    (=>
      (equal ?MORALATTRIBUTE MorallyGood)
      (equal ?UAS 
        (equal (AssignmentFn ?UF ?FORMULA) 1)))
    (=>
      (equal ?MORALATTRIBUTE MorallyBad)
      (equal ?UAS
        (equal (AssignmentFn ?UF ?FORMULA) -1)))
    (=>
      (equal ?MORALATTRIBUTE MorallyNeutral)
      (equal ?UAS
        (equal (AssignmentFn ?UF ?FORMULA) 0)))))   
        
(documentation ValueJudgmentToUtilityAssignmentLikelihoodSentence EnglishLanguage "A UnaryFunction that maps value judgment sentences to utility assignment likelihood sentences.")
(domain ValueJudgmentToUtilityAssignmentLikelihoodSentence 1 SimpleValueJudgmentSentence)
(range ValueJudgmentToUtilityAssignmentLikelihoodSentence UtilitarianSentence)
(instance ValueJudgmentToUtilityAssignmentLikelihoodSentence TotalValuedRelation)
(instance ValueJudgmentToUtilityAssignmentLikelihoodSentence UnaryFunction)

;; What I said in draft 3 is that if something is morally good, then its utility is likely greater than zero.
;; And we can do this sort of translation (over which moral judgments may pass.)
(=> 
  (and 
    (equal (ValueJudgmentToUtilityAssignmentLikelihoodSentence ?VJS) ?UAS)
    (equal ?VJS (modalAttribute ?FORMULA ?MORALATTRIBUTE))
    (instance ?FORMULA Formula)
    (instance ?MORALATTRIBUTE MoralAttribute)
    (instance ?UF UtilityFormulaFn))
  (and
    (=>
      (equal ?MORALATTRIBUTE MorallyGood)
      (equal ?UAS
        (modalAttribute 
          (greaterThan (AssignmentFn ?UF ?FORMULA) 0) Likely)))
    (=>
      (equal ?MORALATTRIBUTE MorallyBad)
      (equal ?UAS
        (modalAttribute 
          (lessThan (AssignmentFn ?UF ?FORMULA) 0) Likely)))
    (=>
      (equal ?MORALATTRIBUTE MorallyNeutral)
      (equal ?UAS
        (modalAttribute 
          (equal (AssignmentFn ?UF ?FORMULA) 0) Likely)))))

(documentation ValueJudgmentToUtilityComparisonSentence EnglishLanguage "A UnaryFunction that maps value judgment sentences to utility comparison sentences.")
(domain ValueJudgmentToUtilityComparisonSentence 1 SimpleValueJudgmentSentence)
(range ValueJudgmentToUtilityComparisonSentence UtilitarianSentence)
(instance ValueJudgmentToUtilityComparisonSentence TotalValuedRelation)
(instance ValueJudgmentToUtilityComparisonSentence UnaryFunction)

;; Basically physical is partitioned into process and object
;; And if I wish to refer to the physical entity that represents a formula, I'd probably go through these.
;; How do we work the Class-Instance stuff into this?
;; (documentation conforms EnglishLanguage "(conforms ?OBJ ?PROP) describes how ?OBJ follows the ideas outlined by ?PROP")
;; (documentation realization EnglishLanguage "A subrelation of represents. (realization ?PROCESS ?PROP) means that ?PROCESS is a Process which expresses the content of ?PROP. Examples include a particular musical performance, which realizes the content of a musical score, or the reading of a poem.")
;; Well, I can just use it as I wish and then re-work definitions... that's the iterative style ;- ). 

;; So if a Formula is morally good, then for all F realizing processes that are possible in the situation 
;; corresponding to the Formula that's good, it's likely that the utility of the good formula is greater than 
;; or equal to the utility of this formula.
;; I think this is showing that for the utility comparisons, we really want to say that "X is morally better than Y"
;; Rather than that it's good or bad.
;; I.e., the moral reasoning that, "it's not good but it's the best we could do."
;; Dunno what to do about morally neutral situations and comparatives.  "Admit", lol.
(=> 
  (and 
    (equal (ValueJudgmentToUtilityComparisonSentence ?VJS) ?UCS)
    (equal ?VJS (modalAttribute ?FORMULA ?MORALATTRIBUTE))
    (instance ?FORMULA Formula)
    (instance ?MORALATTRIBUTE MoralAttribute)
    (instance ?UF UtilityFormulaFn)
    (equal ?SITUATION (SituationFormulaFn ?FORMULA)))
  (and
    (=>
      (equal ?MORALATTRIBUTE MorallyGood)
      (equal ?UCS
        (modalAttribute
          (forall (?F)
            (=> 
              (exists (?AGENT ?CP)
                (and
                  (capableInSituation ?CP agent ?AGENT ?SITUATION)
                  (realizesFormulaSubclass ?CP ?F)))
              (greaterThanOrEqualTo (AssignmentFn ?UF ?FORMULA) (AssignmentFn ?UF ?F)))) Likely)))
    (=>
      (equal ?MORALATTRIBUTE MorallyBad)
      (equal ?UCS
        (modalAttribute 
          (exists (?F ?AGENT ?CP)
            (and 
              (capableInSituation ?CP agent ?AGENT ?SITUATION)
              (realizesFormulaSubclass ?CP ?F)
              (lessThan (AssignmentFn ?UF ?FORMULA) (AssignmentFn ?UF ?F)))) Likely)))
    (=>
      (equal ?MORALATTRIBUTE MorallyNeutral)
      (equal ?UCS
        (modalAttribute 
          (equal (AssignmentFn ?UF ?FORMULA) 0) Likely)))))

(documentation UtilityComparisonToValueJudgmentSentence EnglishLanguage "A UnaryFunction that maps utility comparison sentences to value judgment sentences.")
(domain UtilityComparisonToValueJudgmentSentence 1 UtilityComparisonSentence)
(range UtilityComparisonToValueJudgmentSentence ValueJudgmentSentence)
(instance UtilityComparisonToValueJudgmentSentence TotalValuedRelation)
(instance UtilityComparisonToValueJudgmentSentence UnaryFunction)

;; Let's be super simple and just say that the comparison translates over to the likelihood that each formula is good.
(=> 
  (and 
    (equal (UtilityComparisonToValueJudgmentSentence ?UCS) ?VJS)
    (equal ?UCS (AssignmentFn ?COMPARATOR (AssignmentFn ?UF ?FORMULA1) (AssignmentFn ?UF ?FORMULA2)))
    (instance ?FORMULA1 Formula)
    (instance ?FORMULA2 Formula)
    (instance ?UF UtilityFormulaFn)
    (or
        (equal ?COMPARATOR greaterThan)
        (equal ?COMPARATOR lessThan)
        (equal ?COMPARATOR greaterThanOrEqualTo)
        (equal ?COMPARATOR lessThanOrEqualTo)
        (equal ?COMPARATOR equal)))
  (equal ?VJS 
        (AssignmentFn ?COMPARATOR 
          (probabilityFn (modalAttribute ?FORMULA1 MorallyGood)) 
          (probabilityFn (modalAttribute ?FORMULA2 MorallyGood)))))

;; The following is a partial function because I don't have good technology for recursively going through the structure of the sentences to only translate the "simple utility sentences".
(documentation UtilityToValueJudgmentSentence EnglishLanguage "A UnaryFunction that maps some utility sentences to value judgment sentences.")
(domain UtilityToValueJudgmentSentence 1 UtilitarianSentence)
(range UtilityToValueJudgmentSentence ValueJudgmentSentence)
(instance UtilityToValueJudgmentSentence PartialValuedRelation)
(instance UtilityToValueJudgmentSentence UnaryFunction)

(=> 
  (instance ?UCS UtilityComparisonSentence)
  (equal (UtilityToValueJudgmentSentence ?UCS) (UtilityComparisonToValueJudgmentSentence ?UCS)))

(=>
  (instance ?UAS UtilityAssignmentSentence)
  (equal (UtilityToValueJudgmentSentence ?UAS) (UtilityAssignmentToValueJudgmentSentenceFn ?UAS)))

(=> 
  (and 
    (equal (UtilityToValueJudgmentSentence ?US) VJS)
    (instance ?UF UtilityFormulaFn)
    (equal ?US 
      (and 
        (equal ?SITUATION (SituationFormulaFn ?FORMULA))
        (forall (?F)
          (=> 
            (exists (?AGENT ?CP)
              (and
                (capableInSituation ?CP agent ?AGENT ?SITUATION)
                (realizesFormulaSubclass ?CP ?F)))
            (greaterThanOrEqualTo (AssignmentFn ?UF ?FORMULA) (AssignmentFn ?UF ?F)))))))
  (equal VJS (modalAttribute ?FORMULA MorallyGood)))

(=> 
  (and 
    (equal (UtilityToValueJudgmentSentence ?US) VJS)
    (instance ?UF UtilityFormulaFn)
    (equal ?US 
      (and 
        (equal ?SITUATION (SituationFormulaFn ?FORMULA))
        (exists (?F ?AGENT ?CP)
          (and
            (capableInSituation ?CP agent ?AGENT ?SITUATION)
            (realizesFormulaSubclass ?CP ?F)
            (lessThan (AssignmentFn ?UF ?FORMULA) (AssignmentFn ?UF ?F)))))))
  (equal VJS (modalAttribute ?FORMULA MorallyBad)))

;; Not sure how to specify this.  
;; It has to do with the nature of the utility function, basically, depending on pleasure and pain.
(documentation HedonisticUtilitarianism EnglishLanguage "Hedonistic Utilitarianism is a form of utilitarianism 
that focuses on maximizing pleasure and minimizing pain in evaluating the moral value of an action.")
(subclass HedonisticUtilitarianism Utilitarianism)

(documentation HedonisticUtilitarianTheory EnglishLanguage "A set of hedonistic utilitarian sentences.")
(subclass HedonisticUtilitarianTheory UtilitarianTheory)

;; Gee, I think this can be modularized into some generic Proposition <-> Theory correspondence where I give it two arguments.
(=>
  (instance ?MP HedonisticUtilitarianism)
  (exists (?MT ?MTS)
    (and
      (instance ?MT HedonisticUtilitarianTheory)
      (equal ?MTS (ListAndFn (SetToListFn ?MT)))
      (containsInformation ?MTS ?MP))))
      
(=>
  (instance ?MT HedonisticUtilitarianTheory)
  (exists (?MP)
    (and 
      (instance ?MP HedonisticUtilitarianism)
      (containsInformation (ListAndFn (SetToListFn ?MT)) ?MP))))

(documentation HedonisticUtilityFormulaFn EnglishLanguage "A UnaryFunction that maps Formulas to the net utility 
of that which is described where utility measures the pain and pleasure exhibited in the situation.")
(subclass HedonisticUtilityFormulaFn UtilityFormulaFn)

;; Not a full specification but this could be one way to start expressing the ideas... :S
(=>
  (and
    (instance ?UF HedonisticUtilityFormulaFn)
    (greaterThan (AssignmentFn ?UF ?FORMULA) 0))
  (modalAttribute 
    (exists (?AGENT)
      (causesProposition ?FORMULA (attribute ?AGENT Pleasure))) Possibility))

(=> 
  (exists (?AGENT)
      (causesProposition ?FORMULA (attribute ?AGENT Pleasure)))
  (modalAttribute 
    (exists (?UF)
      (and
        (instance ?UF HedonisticUtilityFormulaFn)
        (greaterThan (AssignmentFn ?UF ?FORMULA) 0))) Possibility))

(=>
  (and
    (instance ?UF HedonisticUtilityFormulaFn)
    (lessThan (AssignmentFn ?UF ?FORMULA) 0))
  (modalAttribute 
    (exists (?AGENT)
      (causesProposition ?FORMULA (attribute ?AGENT Pain))) Possibility))

(=> 
  (exists (?AGENT)
      (causesProposition ?FORMULA (attribute ?AGENT Pain)))
  (modalAttribute 
    (exists (?UF)
      (and
        (instance ?UF HedonisticUtilityFormulaFn)
        (lessThan (AssignmentFn ?UF ?FORMULA) 0))) Possibility))

;; Hedonistic Utilitarianism is that where all utility functions are hedonistic utility functions!
(=> 
  (instance ?HUT HedonisticUtilitarianTheory)
  (forall (?S)
    (=> 
      (element ?S ?HUT)
      (forall (?P ?UF ?FORMULA)
        (=> 
          (and 
            (part ?P ?S)
            (equal ?P (AssignmentFn ?UF ?FORMULA))
            (instance ?FORMULA Formula)
            (instance ?UF UtilityFormulaFn))
          (instance ?UF HedonisticUtilityFormulaFn))))))

;; So next up is what Consequentialism says about the utility function... yay.
;; Then I am sort of wrapping up an dputting together the ethics draft v4!

(documentation Consequentialism EnglishLanguage "Consequentialism is a moral theory that holds 
that 'whether an act is morally right depends only on consequences (as opposed to the circumstances 
or the intrinsic nature of the act or anything that happens before the act)' (Stanford Encyclopedia of Philosophy).")
(subclass Consequentialism Utilitarianism)    

(documentation ConsequentialistTheory EnglishLanguage "A set of consequentialist sentences.")
(subclass ConsequentialistTheory UtilitarianTheory)

(=>
  (instance ?MP Consequentialism)
  (exists (?MT ?MTS)
    (and
      (instance ?MT ConsequentialistTheory)
      (equal ?MTS (ListAndFn (SetToListFn ?MT)))
      (containsInformation ?MTS ?MP))))
      
(=>
  (instance ?MT ConsequentialistTheory)
  (exists (?MP)
    (and 
      (instance ?MP Consequentialism)
      (containsInformation (ListAndFn (SetToListFn ?MT)) ?MP))))
     
(documentation theoryPhilosophyPair EnglishLanguage "This predicate denotes that a (moral) theory and 
a (moral) philosophy as a proposition are paired in the natural manner.") 
(domainSubclass theoryPhilosophyPair 1 Ethics)
(domainSubclass theoryPhilosophyPair 2 MoralTheory)
(relatedInternalConcept theoryPhilosophyPair abstractCounterpart)

;; Let's have fun: if a class of propositions and theories are paired, 
;; Then for each instance of the propositional class, there is a paired instance of the theory class
;; And vice versa.  And we can generally use abstract counterpart for fun.
;; That is, I could generalize the notion to be one over classe of Abstract and classes of Physical ;- ).
(=>
  (theoryPhilosophyPair ?P ?T)
  (and 
    (forall (?IP)
        (=> 
          (instance ?IP ?P)
          (exists (?IT)
            (and 
              (instance ?IT ?T)
              (abstractCounterpart ?IP ?IT)))))
    (forall (?IT)
        (=> 
          (instance ?IT ?T)
          (exists (?IP)
            (and 
              (instance ?IP ?P)
              (abstractCounterpart ?IP ?IT)))))))

(<=>
  (theoryPhilosophyPair ?MP ?MT)
  (and
    (forall (?IMP)
      (=>
        (instance ?IMP ?MP)
        (exists (?IMT)
          (and
            (instance ?IMT ?MT)
            (containsInformation (ListAndFn (SetToListFn ?IMT)) ?IMP)))))
    (forall (?IMT)
      (=>
        (instance ?IMT ?MT)
        (exists (?IMP)
          (and
            (instance ?IMP ?MP)
            (containsInformation (ListAndFn (SetToListFn ?IMT)) ?IMP)))))))
            
;; Now we can simply assert:
(theoryPhilosophyPair Consequentialism ConsequentialistTheory)
(theoryPhilosophyPair HedonisticUtilitarianism HedonisticUtilitarianTheory)
(theoryPhilosophyPair Utilitarianism UtilitarianTheory)
(theoryPhilosophyPair Deontology DeontologicalTheory)
(theoryPhilosophyPair VirtueEthics ValueJudgmentTheory)

;; change name to indicate that it's a class              
(documentation ConsequentialistUtilityFormulaFn EnglishLanguage "A UnaryFunction that maps Formulas to the net utility 
of that which is described where the utility measurement only depends on the consequences of an action.")
(subclass ConsequentialistUtilityFormulaFn UtilityFormulaFn)

;; I we have a utility function and the formula representing a class of actions, 
;; Then everything that influences the result of this function 
;; is a possible consequence/outcome of the class of actions.
;; The definition of influences is just in terms of properties but I think we could define it in terms of 
;; Numbers especially easily, actually!
;; Ok, no, lol, it's not.  Well, I'm moving on for now!
(=>
  (and
    (instance ?UF ConsequentialistUtilityFormulaFn)
    (realizesFormulaSubclass ?CPROC ?FORMULA)
    (subclass ?CPROC AutonomousAgentProcess))
  (forall (?X)
    (=> 
      (influences ?X (AssignmentFn ?UF ?FORMULA))
      (and 
        (instance ?X Outcome)
        (modalAttribute
          (exists (?IPROC)
            (and 
              (instance ?IPROC ?CPROC)
              (result ?IPROC ?X))) Possibility)))))

(=>
  (and
    (instance ?UF ConsequentialistUtilityFormulaFn)
    (realizesFormula ?IPROC ?FORMULA)
    (instance ?IPROC AutonomousAgentProcess))
  (forall (?X)
    (=> 
      (influences ?X (AssignmentFn ?UF ?FORMULA))
      (and 
        (instance ?X Outcome)
        (modalAttribute
          (result ?IPROC ?X) Possibility)))))

;; Can we just port this over?
(=> 
  (instance ?CUT ConsequentialistTheory)
  (forall (?S)
    (=> 
      (element ?S ?CUT)
      (forall (?P ?UF ?FORMULA)
        (=> 
          (and 
            (part ?P ?S)
            (equal ?P (AssignmentFn ?UF ?FORMULA))
            (instance ?FORMULA Formula)
            (instance ?UF UtilityFormulaFn))
          (instance ?UF ConsequentialistUtilityFormulaFn))))))

;; Examples?

;; Ok, this subtly involves a "situation similarity" analysis, again!
;; They're lurking all over ~ ~ ~
;; (forall (?AGENT ?OTHERS ?BEHAVIORCLASS)
;;   (modalAttribute (
;;     (<=>
;;       (exists (?PROC)
;;         (and 
;;           (instance ?PROC ?BEHAVIORCLASS)
;;           (agent ?PROC ?AGENT)
;;           (patient ?PROC ?OTHERS)))
;;       (and 
;;         (desires ?AGENT 
;;         (exists)
;;         (and 
      
;;           instance ?PROC))))
;;   ) Obligation))

;; Just stuff for the presentation:

;; (documentation Utilitarianism EnglishLanguage "Utilitarianism is an ethical theory that determines the moral value of an action based on its consequences, specifically the overall happiness or pleasure it creates or the pain or suffering it prevents. In Hedonistic Utilitarianism, the focus is on maximizing pleasure and minimizing pain.")
;; (subclass Utilitarianism Ethics)

;; (documentation Pleasure EnglishLanguage "Pleasure refers to a positive, enjoyable, or satisfying feeling or experience.")
;; (instance Pleasure PsychologicalAttribute)

;; (documentation Pain EnglishLanguage "Pain refers to an unpleasant sensory or emotional experience, such as physical discomfort, distress, or suffering.")
;; (instance Pain PsychologicalAttribute)

;; (documentation Consequence EnglishLanguage "A Consequence is an event or condition that follows, results from, or is caused by another event or condition, typically an action.")
;; (subclass Consequence Event)

;; (documentation HedonisticUtilitarianism EnglishLanguage "Hedonistic Utilitarianism is a form of utilitarianism that focuses on maximizing pleasure and minimizing pain in evaluating the moral value of an action.")
;; (subclass HedonisticUtilitarianism Utilitarianism)

;; ;; A utility function that maps an action to the net pleasure (pleasure - pain) it creates.
;; (documentation UtilityFn EnglishLanguage "A UnaryFunction that maps an instance of AutonomousAgentProcess to the net pleasure (pleasure - pain) it creates.")
;; (domain UtilityFn 1 AutonomousAgentProcess)
;; (instance UtilityFn TotalValuedRelation)
;; (instance UtilityFn UnaryFunction)
;; (range UtilityFn RealNumber)

;; ;; A morally good action according to Hedonistic Utilitarianism
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyGood)))
;;             (and
;;                 (instance ?BEHAVE AutonomousAgentProcess)
;;                 (forall (?OTHERBEHAVE)
;;                     (=> (and
;;                             (instance ?OTHERBEHAVE AutonomousAgentProcess)
;;                             (not (equal ?BEHAVE ?OTHERBEHAVE)))
;;                         (>= (UtilityFn ?BEHAVE) (UtilityFn ?OTHERBEHAVE))))))))

;; ;; A morally bad action according to Hedonistic Utilitarianism
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyBad)))
;;             (exists (?OTHERBEHAVE)
;;                 (and
;;                     (instance ?OTHERBEHAVE AutonomousAgentProcess)
;;                     (not (equal ?BEHAVE ?OTHERBEHAVE))
;;                     (> (UtilityFn ?OTHERBEHAVE) (UtilityFn ?BEHAVE)))))))

;; ;; A morally good action according to Hedonistic Utilitarianism (version 1)
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyGood)))
;;             (and
;;                 (instance ?BEHAVE AutonomousAgentProcess)
;;                 (greaterThan (UtilityFn ?BEHAVE) 0)))))

;; ;; A morally bad action according to Hedonistic Utilitarianism (version 1)
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyBad)))
;;             (and
;;                 (instance ?BEHAVE AutonomousAgentProcess)
;;                 (lessThan (UtilityFn ?BEHAVE) 0)))))

;; ;; A morally good action according to Hedonistic Utilitarianism (version 2)
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyGood)))
;;             (and
;;                 (instance ?DECIDE Deciding)
;;                 (result ?DECIDE ?BEHAVE)
;;                 (forall (?OPTION)
;;                     (=> (member ?OPTION (DecisionOptionFn ?DECIDE))
;;                         (greaterThanOrEqualTo (UtilityFn ?BEHAVE) (UtilityFn ?OPTION))))))))

;; ;; A morally bad action according to Hedonistic Utilitarianism (version 2)
;; (and
;;     (refers HedonisticUtilitarianism ?STATE)
;;     (instance ?STATE Statement)
;;     (equals ?STATE
;;         (<=>
;;             (and
;;                 (instance ?JUDGE MoralJudging)
;;                 (patient ?JUDGE
;;                     (modalAttribute ?BEHAVE MorallyBad)))
;;             (exists (?DECIDE ?OPTION)
;;                 (and
;;                     (instance ?DECIDE Deciding)
;;                     (result ?DECIDE ?BEHAVE)
;;                     (member ?OPTION (DecisionOptionFn ?DECIDE))
;;                     (greaterThan (UtilityFn ?OPTION) (UtilityFn ?BEHAVE)))))))

;; (instance Change Process)
;; (documentation Change EnglishLanguage "A Change is a subclass of Process that represents an event in which a property of an Entity (which can be an Object or a Process) changes from one state to another.")

;; (=>
;;     (and
;;         (instance ?CHANGE Change)
;;         (patient ?CHANGE ?ENTITY))
;;     (exists (?PROPERTY)
;;         (or
;;             (and
;;                 (holdsDuring
;;                     (BeginFn
;;                         (WhenFn ?CHANGE))
;;                     (property ?ENTITY ?PROPERTY))
;;                 (holdsDuring
;;                     (EndFn
;;                         (WhenFn ?CHANGE))
;;                     (not
;;                         (property ?ENTITY ?PROPERTY))))
;;             (and
;;                 (holdsDuring
;;                     (BeginFn
;;                         (WhenFn ?CHANGE))
;;                     (not
;;                         (property ?ENTITY ?PROPERTY)))
;;                 (holdsDuring
;;                     (EndFn
;;                         (WhenFn ?CHANGE))
;;                     (property ?ENTITY ?PROPERTY))))))

;; (and 
;;     (refers Deontology ?STATE)
;;     (instance ?STATE Statement)
;;     (equal ?STATE
;;         (or
;;             (exists (?RULE)
;;                 (and 
;;                     (modalAttribute ?RULE Obligation)
;;                     (=>
;;                         (realizesFormula ?BEHAVE ?RULE)
;;                         (and 
;;                             (instance ?JUDGE MoralJudging)
;;                             (result ?JUDGE
;;                                 (modalAttribute ?BEHAVE MorallyGood))))
;;                     (=>
;;                         (not 
;;                             (realizesFormula ?BEHAVE ?RULE))
;;                         (and 
;;                             (instance ?JUDGE MoralJudging)
;;                             (result ?JUDGE
;;                                 (modalAttribute ?BEHAVE MorallyBad))))))
;;              (exists (?RULE)
;;                 (and 
;;                     (modalAttribute ?RULE Prohibition)
;;                     (=> 
;;                         (realizesFormula ?BEHAVE ?RULE)
;;                         (and 
;;                             (instance ?JUDGE MoralJudging)
;;                             (result ?JUDGE
;;                                 (modalAttribute ?BEHAVE MorallyBad))))))
;;             (exists (?RULE) 
;;                 (and 
;;                     (modalAttribute ?RULE Permission)
;;                     (=> 
;;                         (and 
;;                             (realizesFormula ?BEHAVE1 ?RULE)
;;                             (prevents ?BEHAVE2 ?BEHAVE1)
;;                             (instance ?BEHAVE2 AutonomousAgentProcess))
;;                         (and 
;;                             (instance ?JUDGE MoralJudging)
;;                             (result ?JUDGE 
;;                                 (modalAttribute ?BEHAVE2 MorallyBad))))))))) 

;; ;;Can you switch the exists and or?

;; (and 
;;     (refers Deontology ?STATE)
;;     (instance ?STATE Statement)
;;     (exists (?RULE)
;;         (or
;;             (and 
;;                 (modalAttribute ?RULE Obligation)
;;                 (=>
;;                     (realizesFormula ?BEHAVE ?RULE)
;;                     (and 
;;                         (instance ?JUDGE MoralJudging)
;;                         (result ?JUDGE
;;                             (modalAttribute ?BEHAVE MorallyGood))))
;;                 (=>
;;                     (not 
;;                         (realizesFormula ?BEHAVE ?RULE))
;;                     (and 
;;                         (instance ?JUDGE MoralJudging)
;;                         (result ?JUDGE
;;                             (modalAttribute ?BEHAVE MorallyBad)))))
;;             (and 
;;                 (modalAttribute ?RULE Prohibition)
;;                 (=> 
;;                     (realizesFormula ?BEHAVE ?RULE)
;;                     (and 
;;                         (instance ?JUDGE MoralJudging)
;;                         (result ?JUDGE
;;                             (modalAttribute ?BEHAVE MorallyBad)))))
;;             (and 
;;                 (modalAttribute ?RULE Permission)
;;                 (=> 
;;                     (and 
;;                         (realizesFormula ?BEHAVE1 ?RULE)
;;                         (prevents ?BEHAVE2 ?BEHAVE1)
;;                         (instance ?BEHAVE2 AutonomousAgentProcess))
;;                     (and 
;;                         (instance ?JUDGE MoralJudging)
;;                         (result ?JUDGE 
;;                             (modalAttribute ?BEHAVE2 MorallyBad))))))))


;; (exists (?I)
;;     (instance ?I ?ClassOfBehavior))

;; Well, I used it, so why not have the log :- p
;; Maybe SUMO will change ~ 
;; (=>
;;     (and
;;         (instance ?JUDGE Judging)
;;         (agent ?JUDGE ?AGENT)
;;         (result ?JUDGE ?P))
;;     (and
;;         (holdsDuring
;;             (BeginFn
;;                 (WhenFn ?JUDGE))
;;             (not
;;                 (believes ?AGENT ?P)))
;;         (holdsDuring
;;             (EndFn
;;                 (WhenFn ?JUDGE))
;;             (believes ?AGENT ?P))))

(subclass IntentionallyHonestCommunication Communication)

(<=>
  (instance ?COMM IntentionallyHonestCommunication)
  (exists (?AGENT ?MESSAGE)
    (=>
      (and
        (instance ?AGENT CognitiveAgent)
        (agent ?COMM ?AGENT)
        (patient ?COMM ?MESSAGE)
        (instance ?MESSAGE Sentence))
      (holdsDuring
        (WhenFn ?COMM)
        (believes ?AGENT
          (truth ?MESSAGE True))))))

(subclass Honesty VirtueAttribute)
(instance Truthfulness Honesty)
(Instance Integrity Honesty)    

(<=> 
  (attribute ?AGENT Truthfulness)
  (desires ?AGENT 
    (forall (?COMM)
      (=>
        (and 
          (instance ?COMM Communication)
          (agent ?COMM ?AGENT))
        (instance ?COMM IntentionallyHonestCommunication)))))

(<=> 
  (attribute ?AGENT Truthfulness)
  (forall (?COMM)
      (=>
        (and 
          (instance ?COMM Communication)
          (agent ?COMM ?AGENT))
        (modalAttribute 
          (instance ?COMM IntentionallyHonestCommunication) Likely))))

(modalAttribute
  (exists (?K ?A1 ?A2)
    (and
        (instance ?K Killing)
        (agent ?K ?A1)
        (patient ?K ?A2)
        (not (equal ?A1 ?A2)))) Prohibition)
