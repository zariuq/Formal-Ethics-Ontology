;; Draft 3 -- because dealing with moral judgments in terms of classes instead of instances 
;; seems substantial enough to warrant possibly revamping a lot!
;; I will not repeat unchanged elements from the Ethics Kifs folder.

(documentation DecidingSubclass EnglishLanguage "The subclass of Selecting where the agent opts for one course of action 
out of a set of multiple possibilities that are open to him/ her, which are represented as subclasses of Process, 
some instance of which can be enacted.")
(subclass DecidingSubclass Selecting)
(termFormat EnglishLanguage DecidingSubclass "deciding")

;; If a subclass of Process is being decided upon by an agent
;; The agent is capable of enacting an instance of the SubProcess
(=>
    (and 
        (instance ?DECIDE DecidingSubclass)
        (agent ?DECIDE ?AGENT)
        (patient ?DECIDE ?PROCESS))
    (capability ?PROCESS agent ?AGENT))

;; Draft 2, being nitpicky, maybe the agent only believes it's capable
;; And will decide on the action based on the belief without actually being able to ðŸ¤ª
(=>
    (and 
        (instance ?DECIDE DecidingSubclass)
        (agent ?DECIDE ?AGENT)
        (patient ?DECIDE ?PROCESS))
    (believes ?AGENT 
        (capability ?PROCESS agent ?AGENT)))

;; If an agent decides on a class of behaviors, then there exists an instance of this class of behaviors
;; that is an intentional process and of which the agent is an agent.
;; A bit of a stretch as agents don't strictly _need_ to act on their conclusions.
;; Just trying to sketch a "class" version of the "instance" Deciding in SUMO.
(=>
    (and
        (instance ?DECIDE DecidingSubclass)
        (agent ?DECIDE ?AGENT)
        (result ?DECIDE ?CPROCESS))
    (exists (?IPROCESS)
        (and
            (instance ?IPROCESS ?CPROCESS)
            (instance ?IPROCESS IntentionalProcess)
            (agent ?IPROCESS ?AGENT))))

;; I think this one is pretty much fine, lol.
;; Actually, it's a bit weird: it makes it seem as if one is choosing between subclasses of LegalDecision,
;; namely, LegalAcquittal, LegalAward, LegalConviction, LegalDismissal, and Sentencing.
;; One could stipulate that sometimes one is choosing among particular instances of a single class of procesess,
;; for exmaple, what sort of conviction to sentence someone to.  
;; A counter-argument would be that one is actually choosing among hitherto unspecified subclasses of LegalConviction.
;; Here, when there's a Legal Decision, there is an act of deciding on a type of legal decision that takes place earlier
;; than the decision.  And the decision is an instance of the type of legal decision decided upon.
;; Which, tbh, seems better than just dealing in instances.
;; (I should really look into what the intended semantics of instances are.  )
(=>
    (instance ?DECISION LegalDecision)
    (exists (?DECIDE)
        (and
            (instance ?DECIDE DecidingSubclass)
            (earlier
                (WhenFn ?DECIDE)
                (WhenFn ?DECISION))
            (result ?DECIDE ?LEGALDECISIONPROCESS)
            (instance ?DECISION ?LEGALDECISIONPROCESS))))

;; This shouldn't be deciding.
(=>
    (ratingsAgent ?RATING ?AGENT)
    (exists (?PROCESS)
        (and
            (instance ?PROCESS Deciding)
            (agent ?PROCESS ?AGENT)
            (result ?PROCESS ?RATING))))

;; So there are only two uses of Deciding in SUMO's KB anyway.
;; The rule in GameCall seems fine as it's vague.  Should probably be Judging.  I don't know enough about it.
;; Voting should perhaps be a subclass of Selecting, not Deciding
;; As one is often not actually selecting courses of action.
;; However, it would seem that all the uses of Voting and VotingFn do not refer to the result at all!
;; Thus all of the subclasses of Deciding can also be subclasses of DecidingSubclass!

;; Resolution could just as well be a subclass of Deciding!
(documentation ResolutionSubclass EnglishLanguage "Any instance of DecidingSubclass which is conducted at a FormalMeeting 
and where the agent is an Organization.")
(subclass ResolutionSubclass Decidingsubclass)

(=>
    (instance ?RESOLUTION ResolutionSubclass)
    (exists (?AGENT ?MEETING)
        (and
            (instance ?AGENT Organization)
            (agent ?RESOLUTION ?AGENT)
            (subProcess ?RESOLUTION ?MEETING)
            (instance ?MEETING FormalMeeting))))

;; I think that covers all the Decision: Instance -> Class update!  Yay ðŸ¥³
;; The first question is: what needs to be changed to suite the DecisionSubclass?

;; Fields of Study are now classes!
(documentation Ethics EnglishLanguage "Ethics is the normative science of the conduct of human beings living in society, 
which judges this conduct to be right or wrong, to be good or bad, or in some similar way. (An Introduction to Ethics (LIllie, 1948))")
(subclass Ethics Philosophy)
(subclass Ethics Science)

(documentation MoralNihilism EnglishLanguage "'Moral Nihilism is the view that nothing is morally wrong' (SEP - Moral Skepticism). 
Moral Nihilism can also be defined as 'the view that there are no moral facts' (Ethics: The Fundamentals).")
(subclass MoralNihilism Ethics)

(documentation Deontology EnglishLanguage "Deontology is the ethical paradigm that judges the morality of an action 
based on the action adheres to a set of rules and principles.")
(subclass Deontology Ethics)

(documentation Utilitarianism EnglishLanguage "Utilitarianism is the ethical paradigm that judges the morality of an action 
based on whether it maximizes the good over the bad, which is typically determined via a utility function.")
(subclass Utilitarianism Ethics)

(documentation VirtueEthics EngnlishLanguage "Virtue ethics is the ethical paradigm that judges the morality of an action 
based on the character of the agent performing an action.  A virtuous agent is one who possesses virtues.  
'An action is right if and only if it is what a virtuous agent would characteristically (i.e., acting in caharacter) 
do in the circumstances' (On Virtue Ethics -- Right Action).")
(subclass VirtueEthics Ethics)

(documentation HedonisticUtilitarianism EnglishLanguage "Hedonistic Utilitarianism is a form of utilitarianism that focuses on maximizing pleasure and minimizing pain in evaluating the moral value of an action.")
(subclass HedonisticUtilitarianism Utilitarianism)

(documentation Consequentialism EnglishLanguage "Consequentialism is a moral theory that holds that 'whether an act is morally right depends only on consequences (as opposed to the circumstances or the intrinsic nature of the act or anything that happens before the act)' (Stanford Encyclopedia of Philosophy).")
(subclass Consequentialism Utilitarianism)

;; Repeated only because I added to them ;- )

;; MorallyGood, VirtueAttribute, VirtuousAgent and the vicious versions can remain the same âœ…
;; AutonomousAgentProcess is good.

; (=>
;     (instance ?JUDGE MoralJudging)
;     (exists (?BEHAVE ?MORAL)
;         (and 
;             (instance ?BEHAVE AutonomousAgentProcess)
;             (instance ?MORAL MoralAttribute)
;             (patient ?JUDGE ?BEHAVE)
;             (result ?JUDGE 
;                 (modalAttribute ?BEHAVE ?MORAL)))))
;; The above (draft 2) is wrong because because ?BEHAVE is a Process, not a Formula.  

;; If there is an instance ?J of Moral Judging, then there exists a class of autonomous agent behavior ?CB and a moral judgment ?M, 
;; such that the it is judged to me ?M for there to exist an instance ?IB of ?CB.
;; -- This actually makes more sense!
(=>
    (instance ?JUDGE MoralJudging)
    (exists (?CBEHAVE ?MORAL)
        (and 
            (subclass ?CBEHAVE AutonomousAgentProcess)
            (instance ?MORAL MoralAttribute)
            (patient ?JUDGE ?CBEHAVE)
            (result ?JUDGE 
                (modalAttribute 
                    (exists (?IBEHAVE) 
                        (instance ?IBEHAVE ?CBEHAVE)) ?MORAL)))))

;; If there is an instance ?J of moral judging, then there exists an autonomous agent behavior ?B and a moral judgment ?M,
;; such that it is judged to be ?M that there is an instance of ?B.
;; -- A bit weird.  There's some precedence in SUMO.
;; I suppose we wish to get at the case where one is simply judging a particular behavior as GOOD or BAD without any clear sense of generalization. 
(=>
    (instance ?JUDGE MoralJudging)
    (exists (?BEHAVE ?MORAL)
        (and 
            (instance ?MORAL MoralAttribute)
            (patient ?JUDGE ?BEHAVE)
            (result ?JUDGE 
                (modalAttribute
                    (instance ?BEHAVE AutonomousAgentProcess) ?MORAL)))))

;; Maybe I wish to say that if there is a case of moral judging ?J, then it is either of the above cases:
;; Judging any instance of a class of behaviors ?M or judging a particular instance to be ?M.
(=>
    (instance ?JUDGE MoralJudging)
    (or
        (exists (?CBEHAVE ?MORAL)
        (and 
            (subclass ?CBEHAVE AutonomousAgentProcess)
            (instance ?MORAL MoralAttribute)
            (patient ?JUDGE ?CBEHAVE)
            (result ?JUDGE 
                (modalAttribute 
                    (exists (?IBEHAVE) 
                        (instance ?IBEHAVE ?CBEHAVE)) ?MORAL))))
        (exists (?BEHAVE ?MORAL)
        (and 
            (instance ?MORAL MoralAttribute)
            (patient ?JUDGE ?BEHAVE)
            (result ?JUDGE 
                (modalAttribute
                    (instance ?BEHAVE AutonomousAgentProcess) ?MORAL))))))

;; Ethics refers to the moral judging of processes (behavior) of members of groups (aka society, lol).
;; Not sure how to get the "normative science" part in.  I think there's a lot of hidden baggage in the term "normative".
(and 
    (refers Ethics ?JUDGE)
    (instance ?JUDGE MoralJudging)
    (instance ?MORAL MoralAttribute)
    (instance ?GROUP Group)
    (instance ?BEHAVE AutonomousAgentProcess)
    (member ?MEMB ?GROUP)
    (agent ?BEHAVE ?MEMB)
    (patient ?JUDGE ?BEHAVE)
    (result ?JUDGE 
        (modalAttribute ?BEHAVE ?MORAL)))
;; The above (draft 2) can be refined because the instance ?MORAL implies the behavior and the moral judgment.

;; This is tricky because I'm including both classes and instances.  Maybe I should drop instances for now.
;; Anyway, I wish to include the idea that the moral judgment is of a member of a group
(and 
    (refers Ethics ?JUDGE)
    (instance ?JUDGE MoralJudging)
    (instance ?GROUP Group)
    (member ?MEMB ?GROUP)
    (patient ?JUDGE ?BEHAVE)
    (=>
        (instance ?BEHAVE AutonomousAgentProcess)
        (agent ?BEHAVE ?MEMB))
    (=> 
        (subclass ?BEHAVE AutonomousAgentProcess)
        (capability ?BEHAVE agent ?MEMB)))

;; Let's add that the agent of the moral judgment is either an inclusive subgroup or a member of the group (with a bit of redundancy!)
(and 
    (refers Ethics ?JUDGE)
    (instance ?JUDGE MoralJudging)
    (instance ?GROUP Group)
    (member ?MEMB ?GROUP)
    (patient ?JUDGE ?BEHAVE)
    (=>
        (instance ?BEHAVE AutonomousAgentProcess)
        (agent ?BEHAVE ?MEMB))
    (=> 
        (subclass ?BEHAVE AutonomousAgentProcess)
        (capability ?BEHAVE agent ?MEMB))
    (agent ?JUDGE ?AGENT)
    (or
        (member ?AGENT ?GROUP)
        (part ?AGENT ?GROUP)))


